
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!-->
<html class="no-js" lang="zh-CN"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Handy's</title>
  <meta name="author" content="Handy.Wang">
  <!--[if lt IE 9]>
    <script src="http://x.papaapp.com/farm1/a571d2/8dda131d/html5shiv.js"></script>
    <![endif]-->
  
  <meta name="description" content="UIImage Stretch May 13th, 2016 一张可拉伸图片的定义－译自iOS原文 一张可拉伸的图片其实给自己定义了一个区域，在这个区域内的图片内容以一种更美观优雅的方式被重复显示。可拉伸图片通常用于视图的背景，因为这种图片可以按拉伸区域的定义被撑大或缩小， &hellip;">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.handy.wang/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script type="text/javascript" src="http://t.papaapp.com/js/libs/jquery/1.7.2/jquery.js"></script>
  <link href="/atom.xml" rel="alternate" title="Handy's" type="application/atom+xml">

  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->

  

</head>
<body   >
  <header id="header" class="clearfix">    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                <a id="logo" href="/">
                   Handy's
                </a>
                <p class="description">Stay hungry, stay foolish.</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="index-nav current" href="/">Blog</a>
<a class="archives-nav" href="/blog/archives">Archives</a>
                </nav>
            </div>
        </div>
    </div>
</header>
  <div id="body">
    <div class="container">
    	<div class="col-group">
			  <div class="col-8" id="main">
    <div class="res-cons">
    
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2016/05/13/uiimage-stretch/">UIImage Stretch</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2016-05-13T15:05:40+08:00" pubdate data-updated="true">May 13<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="post-content"><h2>一张可拉伸图片的定义－译自<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImage_Class/#Defining%20a%20Stretchable%20Image">iOS原文</a></h2>

<br />


<p>一张可拉伸的图片其实给自己定义了一个区域，在这个区域内的图片内容以一种更美观优雅的方式被重复显示。可拉伸图片通常用于视图的背景，因为这种图片可以按拉伸区域的定义被撑大或缩小，从而以一种更美观的方式来填充视图区域。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/05/13/uiimage-stretch/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2016/05/04/kuo-zhan-uitextview-and-uitextfieldzhi-chi-jiu-gong-ge-dui-qi-fang-shi/">扩展UITextView &amp; UITextField支持九宫格对齐方式</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2016-05-04T21:27:05+08:00" pubdate data-updated="true">May 4<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="post-content"><h3>目标</h3>

<p>iOS原生的 UITextField 和 UITextView 只支持文本内容的左、中、右对齐，但是目前我的需求是需要让UITextField 和 UITextView 支持9宫格对齐方式，并能按此对齐方式进行正常输入，如下图：</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/05/04/kuo-zhan-uitextview-and-uitextfieldzhi-chi-jiu-gong-ge-dui-qi-fang-shi/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2016/01/29/sdwebimagehuan-cun-zhi-tu-pian-urlbu-bian/">SDWebImage缓存之图片URL不变</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2016-01-29T10:35:08+08:00" pubdate data-updated="true">Jan 29<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="post-content"><pre><code>SDWebImage在iOS项目中是一个很常用的开源库，而且众所周知的是，它是基于URL作为Key来实现图片缓存机制的。在90%左右的情况下，
图片与URL是一一对应的，即使服务器修改了图片也会相应的变更URL。但是在少数情况下，服务器修改了图片后不会变更相应的URL，也就是
说图片本身的内容变了然而它的URL没有变化，那么按照对SDWebImage的常规使用方法的话，客户端肯定更新不到同一URL对应到服务器已变
更的图片内容。
</code></pre>

<p>基于这一现象，我们来进行分析。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/01/29/sdwebimagehuan-cun-zhi-tu-pian-urlbu-bian/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2016/01/26/ios-crashfen-xi/">iOS Crash快速分析实战</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2016-01-26T10:57:50+08:00" pubdate data-updated="true">Jan 26<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="post-content"><pre><code>实际开发中或使用App过程中遇到App crash是一件很常见的事儿，但是要能快速定位是哪一行代码导致的可能就不一定是件易事儿了。
在这里我结合自己与别人遇到过的坑，总结了一下。
</code></pre>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/01/26/ios-crashfen-xi/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2015/12/10/software-architecture-patterns/">软件架构模式（译）</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2015-12-10T16:10:37+08:00" pubdate data-updated="true">Dec 10<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="post-content"><p>原文：<a href="http://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf">《Software Architecture Patterns》</a></p>

<br/>


<h1>前言</h1>

<p>对于很多开发人员来说，在着手开发时并没有一套有条理的架构体系来指导他们，这简直是一件太正常的事情了。在没有一套清晰的、经过推敲过的架构体系时，许多开发人员和架构师都遵守所谓的行业标准－分层架构模式（也称之为多层架构），即创建隐式的多层结构，即把只是从源代码角度，把模块的源代码都放在不同的源代码路径下，看似像分层了。但，实际上这种层次架构有诸多问题：模块角色没有清晰地划分，模块职责不明确，模块间的关系不清楚。这种架构通常称之为：<a href="http://www.cin.ufpe.br/~sugarloafplop/mud.pdf">大泥球</a>-架构反模式</p>

<p>缺少有条理的架构的应用通常都是紧耦合的、不健壮的、难以维护的，而且没有清晰的视野感和方向感。所以，非常难以确定这个应用的架构特点，以至于不能全面地理解这个应该系统中各模块的内部逻辑。很难找到与开发和维护相关的诸多基本问题的答案：这个应用具有伸缩性吗？这个应用有什么性能特点？这个应用是否很容易维护？这个应用有什么技术特性？</p>

<p>诸多架构模式可以辅助我们定义应用程序的基本特性和行为。例如，某些架构模式偏向于高可伸缩性，某些架构模式偏向于高度敏捷性。所以，在选择一种适合于某个项目的架构之前，了解不同架构模式的特点、优点和缺点是非常有必要的。</p>

<p>作为一名架构师，你需要经常检验你的架构决策，尤其是在选择某种特别的架构或方案的时候。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/12/10/software-architecture-patterns/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2015/12/06/2015nian-wo-du-gan-ma-liao/">2015年我都干嘛了</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2015-12-06T11:33:18+08:00" pubdate data-updated="true">Dec 6<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="post-content"><p>2015年即将结束，那这一年我到底都干嘛了？</p>

<pre><code>从去年(2014)的12月份就开始暗无天日的加班忙碌，直到今天下半年才好了很多，眼看这就要要2016了，
也该回顾一下2015年的工作了。
</code></pre>

<h4>AutoLayout</h4>

<p>2015年12月，加入了一个新团队－嗨购，仍然是负责iOS项目开发，人员上加上我两人，版本处于0.0.1版本。</p>

<p>当时接收项目后，发现这个项目的界面采用storyboard+autolayout开发，另外那个哥们去AutoLayout的使用也处于学习阶段，所以遇到的主要问题就是修改界面的Bug。由于我之前没有使用过storyboard和autolayout，再加上UI设计师对界面的细节控制要求很高，所以有些应付不了了。在另一个哥们儿的辅助下，将就着开发了0.1.0版本(仍采用storyboard+autolayout)，其实这个过程非常苦恼，“是好好学习一下AutoLayout，然后在项目里继续使用AutoLayout呢？” 还是 “采用自己熟悉的纯代码方式来编写？”</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/12/06/2015nian-wo-du-gan-ma-liao/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2015/10/11/uiviewyu-calayerzhong-dong-hua-de-chuang-jian-he-zhi-xing-guo-cheng/">UIView与CALayer中动画的创建和执行过程</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2015-10-11T22:49:40+08:00" pubdate data-updated="true">Oct 11<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="post-content"><h2>写在最前面</h2>

<p>本文假设您已有RunLoop和CAAnimation的相关知识，所以这里不对<a href="http://blog.handy.wang/blog/2014/05/26/runloopxue-xi-bi-ji-1/">RunLoop</a>和CAAnimation的细节进行介绍。但是，这里仍然要提前提及几个知识点：CFRunLoopActivity、CAAction、CAAnimation、CATransaction</p>

<p><strong>RunLoop的6个CFRunLoopActivity</strong></p>

<pre><code>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL &lt;&lt; 0),//即将进入RunLoop
    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),//Timer即将触发
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),//Source0即将触发
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),//RunLoop即将休眠
    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),//RunLoop已被唤醒
    kCFRunLoopExit = (1UL &lt;&lt; 7),//RunLoop已结束
    kCFRunLoopAllActivities = 0x0FFFFFFFU
};
</code></pre>

<p><strong>CAAction</strong>
CAAction即动画行为，它是一个protocol(CAAnimation实现了此protocol)，即定义一个动画要做的事情。比如，我们平时无论是否在Animaiton block里修改View的属性时，都会触发Core Animation回调CALayer，再回调UIView来获取CAAction(如：CABasicAnimation)，如果不在Animaiton block里修改View的属性时获取到的是[NSNull null]，在Animaiton block里修改View的属性时获取到的是CABasicAnimation等(后面有图标这个过程)，也可以返回自定义的动画(实现了CAAction的动画)。</p>

<p><strong>CAAnimation的继承结构</strong></p>

<p><img src="https://raw.githubusercontent.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/img/uiview_calayer_animation_creation_caanimation_hierarchy.jpg" alt="CAAnimation.jpg" /></p>

<p><strong>CATransaction</strong>
CATransacton是一个与动画相关的概念，它负责把多个对Layer或View的可动画属性的修改集中在一起一次性提交并执行，所以Animation应该需要被包含在CATransaction中的。CATransaction分为<strong>隐式</strong>和<strong>显示</strong>。
如下，这就是一个<strong>显示的CATransaction</strong>代码片断，即由开发人员来begin和commit。</p>

<pre><code>[CATransaction begin];
[CATransaction setValue:@(NO) forKey:kCATransactionDisableActions];
[CATransaction setValue:@(0.5) forKey:kCATransactionAnimationDuration];
[CATransaction setValue:^() {NSLog(@"Completion...");} forKey:kCATransactionCompletionBlock];
_animLayer.position = CGPointMake(_animLayer.position.x, _animLayer.position.y - 10);
[CATransaction commit];
</code></pre>

<p>从代码片断中可见虽然只是修改了layer的position，但是最终动画的duration、动画回调都可能通过CATransaction来提供。当不是简单的修改position，而是给layer加一个CAAnimation时，最终动画的duration等参数则是以CAAnimation的内容为主。同时，CATransaction支持嵌套，以最外层commit为准。这里还需要关注一下对kCATransactionDisableActions的修改，kCATransactionDisableActions表示是否禁用CAAction的检索：若为YES则禁用，即无论在动画代码块里的UI属性修改都不会有动画效果，actionForKey:方法不会回调；若为NO则开启CAAction的检索。</p>

<p>关于<strong>隐式的CATransaction</strong>，有<a href="http://blog.csdn.net/yaozhuoyu/article/details/9533909">资料</a>说是</p>

<pre><code>在大多数情况下，我们并不需要去创建自己的transaction。
当我们给layer添加一个显式或者隐式的动画的时候，core animation会自动的为我们创建一个隐式的
transaction。
</code></pre>

<p>也有<a href="http://geeklu.com/2012/09/animation-in-ios/">资料</a>说是</p>

<pre><code>CATransaction也分两类,显式的和隐式的,当在某次RunLoop中设置一个animatable属性的时候,
如果发现当前没有事务,则会自动创建一个CA事务
</code></pre>

<p>但是，无论通过修改Layer的position属性来达到隐式动画效果时，还是通过修改View的center属性达到显式动画效果时断点+[CATransaction begin]、CA::Transaction::create()方法都没有被调用，说明没有新创建CATransaction.</p>

<pre><code>隐式动画
_animLayer.position = CGPointMake(_animLayer.position.x, _animLayer.position.y - 10);

显式动画
[UIView animateWithDuration:0.5 animations:^{
    _animView.center = CGPointMake(_animView.center.x, _animView.center.y - 10);
}];
</code></pre>

<p>但是前面我们提到Animation是要依附于CATransaction的commit才得以执行的，而且我们在实验隐式动画和显式动画时，当CAAction被查找(后面会图示)完成后CA::Transaction:commit会被调用到，所以RunLoop回调进行创建动画的过程时应该事先已创建了一个根Transaction，再次通过断点CA::Transaction::create方法也证明了Main RunLoop通过回调<strong><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></strong>只调用了一次CA::Transaction::create方法来创建了一个根Transaction，所以这就能解释能为什么隐式动画和显式动画时Core Animation内部没有新创建CATransaction而只是在动画CAAction返回后调用CA::Transaction:commit就可以执行动画了。所以，我理解的隐式CATransaction是指前面提到的根Transaction。</p>

<h2>正文</h2>

<p>在了解了以上知识后，我才会告诉你，本文主要是介绍我们在UIView或CALayer中通过动画块或不通过动画块来修改其属性时的动画创建和执行过程。先看一段代码，如下：</p>

<pre><code>代码一：隐式动画
_animLayer = [IDCAAnimationTestLayer new];
_animLayer.position = CGPointMake(_animLayer.position.x, _animLayer.position.y - 10);

代码二：无动画效果
_animView.layer.position = CGPointMake(_animView.layer.position.x, _animView.layer.position.y - 10);

代码三：无动画效果
[CATransaction begin];
[CATransaction setValue:@(NO) forKey:kCATransactionDisableActions];
[CATransaction setValue:@(0.5) forKey:kCATransactionAnimationDuration];
_animView.layer.position = CGPointMake(_animView.layer.position.x, _animView.layer.position.y - 10);
[CATransaction commit];

代码四：显式动画
[UIView animateWithDuration:0.5 animations:^{
    _animView.center = CGPointMake(_animView.center.x, _animView.center.y - 10);
}];

代码五：无动画效果
_animView.center = CGPointMake(_animView.center.x, _animView.center.y - 10);
</code></pre>

<p>从以上代码中可以看到：为什么同样是对CALayer或UIView的相同属性作修改，而有些有动画而有些没有动画呢？带着这个疑问，我们接下来看下面这张图。</p>

<p><img src="https://raw.githubusercontent.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/img/uiview_calayer_animation_creation_callprocess.jpg" alt="E_UIView:CALayer的动画创建及执行过程.jpg" />
如上图，我来分别梳理一个修改CALayer和UIView属性时的动画创建过程(没错，其实不在动画块里修改属性也有动画创建过程存在的)。</p>

<h5>CALayer的动画创建和执行过程(如图中黑实线箭头及序号)</h5>

<ol>
<li>RunLoop触发两类回调事件：BeforeWaiting、点击事件、ExitRunLoop</li>
<li>RunLoop回调事件回调到开发人员写的修改CALayer属性的代码</li>
<li>当修改CALayer的animatable属性时会触发CALayer自己的actionForKey:方法来查找相应的CAAction，CALayer的actionForKey方法的默认实现会返回一个实现了CAAction protocol的CAAnimation，如CABasicAnimation</li>
<li>开发人员的修改CALayer属性的代码执行完毕后，在RunLoop的回调函数的后续逻辑会调用CA::Transaction:commit()来提交之前修改CALayer属性而生成的CAAction.</li>
<li>最后相应的动画效果显示到屏幕上(TODO:这里的细节还有待调研)</li>
</ol>


<h5>UIView的动画创建和执行过程(如图中虚线箭头及序号)</h5>

<ol>
<li>RunLoop触发两类回调事件：BeforeWaiting、点击事件、ExitRunLoop</li>
<li>RunLoop回调事件回调到开发人员写的修改UIView几何或透明度等UI属性的代码，这里修改有两种情况如下：
2.1.1 不在动画代码块里修改UIView属性：修改UIView的几何、透明度等UI属性实际上最终是通过CALayer的对应属性修改来体现的，如修改UIView的center实际上最终是通过CALayer的position来体现的。
2.1.2 在动画代码块里修改UIView属性
2.2 如2.1.1所说，无论是否在动画代码块里修改UIView的几何、透明度等UI属性，实际上是通过CALayer修改对应属性来完成的，这是因为UIView与CALayer的关系是平行的，且UIView是CALayer的Delegate。</li>
<li>与<strong>CALayer的动画创建和执行过程</strong>的流程一致。但是需要注意的是：如果是2.1.1触发这一步，那么返回的是[NSNull null]，即没有动画(表示停止对CAAction的检索)；如果是2.1.2触发这一步，那么返回的结果与<strong>CALayer的动画创建和执行过程</strong>第3步一样，即实现了CAAction protocol的CAAnimation子类。从这两种情况我们就不难明白，为什么不在动画代码块里修改UIView的UI属性没有动画，反之有动画，这都是由actionForKey:是否有确切的CAAction值决定的。顺带讲一下，actionForKey:有三种返回值情况：id<CAAction>、nil，nil表示没有没有任何动画行为。</li>
<li>同<strong>CALayer的动画创建和执行过程</strong></li>
<li>同<strong>CALayer的动画创建和执行过程</strong></li>
</ol>


<p>讲到这里，我再来回顾前面的问题<strong>“为什么同样是对CALayer或UIView的相同属性作修改，而有些有动画而有些没有动画呢？”</strong>，再来看一下代码并作相应解释：</p>

<pre><code>代码一：隐式动画
_animLayer = [IDCAAnimationTestLayer new];
_animLayer.position = CGPointMake(_animLayer.position.x, _animLayer.position.y - 10);
解释：这里首先解释一个名词叫Root Layer和非Root Layer。很简单，Root Layer就是指有对应UIView的Layer，
非Root Layer就是指没有对应UIView的Layer，在CALayer里只有对非Root Layer的UI属性修改才会有隐式动画效果。
其实，不难理解，因为Root Layer有UIView，且修改UI属性的代码没有写到动画代码块里，
所以CAAction的返回被UIView的actionForLayer:forKey:方法返回为[Null null]，进一步回调到CALayer里actionForKey:的返回值为nil。
但是，如果在动画代码块里修改Root Layer的UI属性是会有动画效果的。
显然，_animLayer是一个非Root Layer，修改position属性后会按照上面的“CALayer的动画创建和执行过程”来执行，所以有动画效果。

代码二：无动画效果
_animView.layer.position = CGPointMake(_animView.layer.position.x, _animView.layer.position.y - 10);
解释：显然_animView.layer是一个Root Layer，而且没有写在动画代码块里，所以不会有隐式动画。

代码三：无动画效果
[CATransaction begin];
[CATransaction setValue:@(NO) forKey:kCATransactionDisableActions];
[CATransaction setValue:@(0.5) forKey:kCATransactionAnimationDuration];
_animView.layer.position = CGPointMake(_animView.layer.position.x, _animView.layer.position.y - 10);
[CATransaction commit];
解释：同**代码二**

代码四：显式动画
[UIView animateWithDuration:0.5 animations:^{
    _animView.center = CGPointMake(_animView.center.x, _animView.center.y - 10);
}];
解释：参见**UIView的动画创建和执行过程**及其中的2.1.2点，所以有动画效果。

代码五：无动画效果
_animView.center = CGPointMake(_animView.center.x, _animView.center.y - 10);
解释：参见**UIView的动画创建和执行过程**及其中的2.1.1点，所以没有动画效果。
</code></pre>

<p>以上内容就是本章的全部内容，欢迎邮件到nnnwjs@126.com讨论。</p>

<h2>参考</h2>

<ul>
<li><a href="http://blog.handy.wang/blog/2014/05/26/runloopxue-xi-bi-ji-1/">RunLoop学习笔记(一) 基本原理介绍</a></li>
<li><a href="http://blog.csdn.net/yaozhuoyu/article/details/9533909">Core Animation 高级动画技巧</a></li>
<li><a href="http://geeklu.com/2012/09/animation-in-ios/">谈谈iOS Animation</a></li>
<li><a href="http://www.jianshu.com/p/8c1c1697c0ce">iOS开发基础知识：Core Animation(核心动画)</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=4#wechat_redirect">iOS 事件处理机制与图像渲染过程</a></li>
<li>参考以上资料的过程一定要做实验</li>
</ul>

</div>
  
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2015/10/03/uiviewyu-calayerxie-zuo-xuan-ran-jie-mian-de-guo-cheng/">UIView与CALayer协作渲染界面的过程</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2015-10-03T01:38:49+08:00" pubdate data-updated="true">Oct 3<span>rd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="post-content"><h2>预热</h2>

<p>在聊这个话题前，我先简单的说说与本文相关的几个iOS核心Framework及它们之间的关系：UIKit Framework、QuartzCore Framework(CoreAnimation)、CoreGraphics Framework.</p>

<p>另外，为了能更好的理解本文要讲解的逻辑机制，建议先熟悉一下RunLoop机制，我<a href="http://blog.handy.wang/blog/2014/05/26/runloopxue-xi-bi-ji-1/">在这里</a>有作讲解。</p>

<p><strong>注意1</strong>：可以看到上面提到的技术点中的CoreAnimation没有叫 <del>CoreAnimation Framework</del> 。为什么呢？因为CoreAnimation不是被单独地打包到一个Framework里的，而是属于QuartzCore Framework的一部分，奇怪的是QuartzCore.h里只引用了CoreAnimation.h。</p>

<pre><code>  /* QuartzCore.h
   Copyright (c) 2004-2015, Apple Inc.
   All rights reserved. */

#ifndef QUARTZCORE_H
#define QUARTZCORE_H

#include &lt;QuartzCore/CoreAnimation.h&gt;

#endif /* QUARTZCORE_H */
</code></pre>

<p><strong>注意2</strong>：提前了解这几个Framework非常重要，可以辅助我们理解它们各自的职责，以便进一步理解后面会讲解的UIView与CALayer的协作时为什么不同的协作点是相应Framework来参与。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/10/03/uiviewyu-calayerxie-zuo-xuan-ran-jie-mian-de-guo-cheng/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2014/06/11/runloopxue-xi-bi-ji-ren-er-afnetworkingzhong-de-ying-yong/">RunLoop学习笔记(二) AFNetworking中的应用</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2014-06-11T11:16:27+08:00" pubdate data-updated="true">Jun 11<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="post-content"><p>如果理解了上一篇RunLoop原理的内容，那么再来看AFNetworking的核心网络请求部分就很简单了。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/06/11/runloopxue-xi-bi-ji-ren-er-afnetworkingzhong-de-ying-yong/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
    
      <article class="post">
        
  <header>
    
      <h2 class="post-title"><a href="/blog/2014/05/26/runloopxue-xi-bi-ji-1/">RunLoop学习笔记(一) 基本原理介绍</a></h2>
    
    
      <p class="post-meta">
        








  


<time datetime="2014-05-26T17:20:41+08:00" pubdate data-updated="true">May 26<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="post-content"><p>在iOS实际开发中，大家一定遇到过以下问题：</p>

<ul>
<li>在一个线程里启动一个timer，但是这个timer一次也不会被调用？</li>
<li>在一个线程里发起一个NSURLConnection网络数据请求，但是NSURLConnection的delegate没有回调？</li>
<li><p>在主线程环境下的一个方法体里的第一行调用performSelector:withObject:afterDelay:这种带afterDelay的方法簇时，这一行代码实际执行时机往往是在方法体执行过程的最后，为什么呢？如下：</p>

<pre><code>  - (void)testPerformSelectorAfterDelay {
      [self performSelector:@selector(printMyName) withObject:nil afterDelay:0];
      for (int i=0; i &lt; 10; i++) {
          NSLog(@"index is %d", i);
      }
  }

  - (void)printMyName {
      NSLog(@"My name is Handy.Wang ...");
  }

  输出结果是：
  2016-02-21 16:40:25.880 RunLoopXX[3782:200607] index is 0
  2016-02-21 16:40:25.880 RunLoopXX[3782:200607] index is 1
  2016-02-21 16:40:25.880 RunLoopXX[3782:200607] index is 2
  2016-02-21 16:40:25.880 RunLoopXX[3782:200607] index is 3
  2016-02-21 16:40:25.881 RunLoopXX[3782:200607] index is 4
  2016-02-21 16:40:25.881 RunLoopXX[3782:200607] index is 5
  2016-02-21 16:40:25.881 RunLoopXX[3782:200607] index is 6
  2016-02-21 16:40:25.881 RunLoopXX[3782:200607] index is 7
  2016-02-21 16:40:25.881 RunLoopXX[3782:200607] index is 8
  2016-02-21 16:40:25.881 RunLoopXX[3782:200607] index is 9
  2016-02-21 16:43:03.736 RunLoopXX[3782:200607] My name is Handy.Wang ...
</code></pre></li>
</ul>


<p>下面，我就从实际问题出发，来分享一下关于RunLoop的基本知识，同时解决上面三个问题。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/05/26/runloopxue-xi-bi-ji-1/">继续阅读 &rarr;</a>
    </footer>
  


      </article>
    
      <div class="page-navigator">
        
        <a class="prev" href="/blog/page/2/">&larr; Older</a>
        
        <div class="nav-center">
        <a href="/blog/archives">Archives</a>
        </div>
        
      </div>
     </div>
  </div>
    
  <aside id="secondary">
  
    <section class="widget">
    <form id="search" action="https://www.google.com/search" method="get">
    	<input type="hidden" name="q" value="site:blog.handy.wang"/>
    	<input type="text" name="q" results="0" class="text" placeholder="Google搜索"/>
    </form>
</section>

<section class="widget">
	<h3 class="widget-title">最新文章</h3>
	<ul class="widget-list">
		
     	<li>
      	  <a href="/blog/2016/05/13/uiimage-stretch/">UIImage stretch</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2016/05/04/kuo-zhan-uitextview-and-uitextfieldzhi-chi-jiu-gong-ge-dui-qi-fang-shi/">扩展UITextView &amp; UITextField支持九宫格对齐方式</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2016/01/29/sdwebimagehuan-cun-zhi-tu-pian-urlbu-bian/">SDWebImage缓存之图片URL不变</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2016/01/26/ios-crashfen-xi/">iOS Crash快速分析实战</a>
      	</li>
    	
     	<li>
      	  <a href="/blog/2015/12/10/software-architecture-patterns/">软件架构模式（译）</a>
      	</li>
    	
	</ul>
</section>




  
  </aside>


      	</div>
    </div>
  </div>
  <footer id="footer">
  	<div class="container">
	Copyright &copy; 2016 - Handy.Wang -
  <span class="credit">Powered by <a rel="nofollow" href="http://octopress.org">Octopress</a> on <a rel="nofollow" href="http://pages.github.com/">GitHubPages</a>
  </span>
  - <span class="credit">Theme by <a rel="nofollow" href="http://pagecho.com">Cho</a></span>


</div>

  </footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
