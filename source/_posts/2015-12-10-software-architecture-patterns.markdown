---
layout: post
title: "软件架构模式（译）"
date: 2015-12-10 16:10:37 +0800
comments: true
categories: 
---
原文：[《Software Architecture Patterns》](http://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf)

<br/>

#前言

对于很多开发人员来说，在着手开发时并没有一套有条理的架构体系来指导他们，这简直是一件太正常的事情了。在没有一套清晰的、经过推敲过的架构体系时，许多开发人员和架构师都遵守所谓的行业标准－分层架构模式（也称之为多层架构），即创建隐式的多层结构，即把只是从源代码角度，把模块的源代码都放在不同的源代码路径下，看似像分层了。但，实际上这种层次架构有诸多问题：模块角色没有清晰地划分，模块职责不明确，模块间的关系不清楚。这种架构通常称之为：[大泥球](http://www.cin.ufpe.br/~sugarloafplop/mud.pdf)-架构反模式

缺少有条理的架构的应用通常都是紧耦合的、不健壮的、难以维护的，而且没有清晰的视野感和方向感。所以，非常难以确定这个应用的架构特点，以至于不能全面地理解这个应该系统中各模块的内部逻辑。很难找到与开发和维护相关的诸多基本问题的答案：这个应用具有伸缩性吗？这个应用有什么性能特点？这个应用是否很容易维护？这个应用有什么技术特性？

诸多架构模式可以辅助我们定义应用程序的基本特性和行为。例如，某些架构模式偏向于高可伸缩性，某些架构模式偏向于高度敏捷性。所以，在选择一种适合于某个项目的架构之前，了解不同架构模式的特点、优点和缺点是非常有必要的。

作为一名架构师，你需要经常检验你的架构决策，尤其是在选择某种特别的架构或方案的时候。

<!--more-->
<br/>
#第一章 分层架构模式

最常见的架构模式是分层架构模式，也称之为多层架构模式。它是一种适用于大多数`Jave EE`应用的行业标准，被很多架构师、设计师、攻城师所熟知；它与众多公司传统方式的技术交流和组织结构很对口，从而成为众多业务开发工作的首选。

##模式介绍
分层架构模式采用横向划分的方式把的各组件划分到相应的层级里面，每层结构在应用里都担任着特定的角色（比如，视图层负责UI展示、业务逻辑层负责业务逻辑处理）。虽然在分层架构模式的理念里没有强制要求分几层，但是一般分为四层：**展现层、业务层、持久化层和数据库层**（`如图Figure 1-1.`）。在某些情况下，业务层和持久化层统一合并到业务层，尤其是在持久化逻辑代码（比如：SQL或HSQL）被直接写在业务层的各组件中的时候。所以，一般小型应用只有三层架构，而大型的或更复杂的应用则会有五层或更多层架构。

每层架构在应用中都有着特定的角色和职责。例如，展现层是负责处理处所有界面显示和用户浏览时的逻辑，而业务层是充当处理业务请求相关事宜的角色。每层架构都是围绕它需要处理的特定业务逻辑的本职工作进行抽象的。例如，展现层不需要也不用担心将要显示的数据是从哪儿来的，它只需要负责把得到的数据按一定样式显示正确就行。同理，当业务层从某个地方获取到业务数据后，不需要关心这些数据以什么样的样式或形态显示到屏幕后，它只需要关注从持久层获取数据并对这些按一定的逻辑规则加工就好（比如，数据计算或数据整理工作），然后把最终的数据传递给展示层。

![Figure 1-1](https://raw.githubusercontent.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/img/software_architecture_patterns_figure1_1.png "Figure 1-1")

其中，分层架构的重要特性之一是各层架构中的组件分工明确。即，每个组件只会处理它所属那层架构的工作。例如，展现层中的组件只会处理展示逻辑，业务层中的组件只会处理业务逻辑。这种对组件的分门别类就构建成了角色明确、职责分明的分层架构，以及易于开发、测试、管理和维护的应用。所以，各层架构中各个组件的接口功能和作用域的良好定义就显示尤其重要了。

##关键理念

**`封闭性`**－注意`图Figure 1-2`中，每层架构的右侧都有一个“CLOSED”标签。这是分层架构中其中一个非常重要的理念－封闭。封闭的分层表示：当请求在多层间传递时，它要经过多层传递才会传递到目标层。例如，从展现层发起一个请求，这个请求首先需要经过业务层，再经过持久化层，才能最终到达数据库层。

![Figure 1-2](https://raw.githubusercontent.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/img/software_architecture_patterns_figure1_2.png "Figure 1-2")

然而，为什么不允许展现层直接访问其它的各层（持久层或数据库层）呢？因为按常规思维，展现层直接访问数据库层要比经过多层传递后才能查询或保存数据的效率要高得多呀，为什么呢？这个答案就存在于另一个关键理念之中－每层架构的隔离性。

**`隔离性`**－每层架构的隔离性是指每层内部的修改不会对其它层造成任何影响：层内的任何改变都被隔离于其它层及相关层(比如，含有SQL的持久层)之外。如果允许展现层直接访问持久层，那么对持久层SQL的修改就会同时影响到业务层和展现层，这样做显示使得应用的各层之间的组件都产生了各种复杂依赖、紧耦合。这样的架构非常难于维护。

隔离还意味着分层架构的每层都是独立的，因此每层都不感知其它层内的逻辑细节。为了能很好的理解隔离理念的强大和重要，那么试想一下这种情况：

	在花九牛二虎之力把展现层的技术方案由JSP重构为JSF时，只要展示层与业务层之间的对接协议保持不变(例如，使用某个Model数据结构),
	那么业务层是不会受展现层技术方案重构影响的，而且其它层更是完全独立于展现层的界面技术方案的。

****相关知识点：****JSP[^1]、JSF[^2]<br/><br/>
[^1]: [JSP详细资料](https://docs.oracle.com/javaee/5/tutorial/doc/bnagx.html)
[^2]: [JSF详细资料](http://docs.oracle.com/javaee/6/tutorial/doc/bnaph.html)

按以上介绍，当具备封闭性的架构层促成了隔离性的架构层以及层与层之间的修改能达到隔离时，那么是时候可以合理地使一些架构层开放了。例如：你可以给业务层增加一个其内部组件可以访问的且包含了很多通用组件的共享服务层（其内包含了数据、字符串工具类或辅助类和日志类）。其实，创建一个服务层一直是一个非常好的设计，因为这个设计从架构上限定：业务层可以访问共享层，而不是展现层可以访问共享层。如果没有这种分层的架构设计，那么将完全不能从架构上来阻止展现层对共享服务层的访问，而且很难管理这种访问受限的情况。

在上面这个为业务层开放了一个共享服务层的例子中，新的服务层应该处于业务层的下面以表明展现层是不能直接访问共享层的。但是，这样的层次结构有一个问题，即：业务层必须要经过共享服务层才能访问到持久化层，如果真是这样的话，就不合理了。这是分层架构一直存在的一个老问题，不过已经通过创建**具有开放特性的架构层**的方式解决了。

如`图Figure 1-3`所示，图中的服务层右侧有一个“开放”的绿色标签，说明这一层是具有有开放性的，即上层来的请求可以绕开它，从而请求可以直接被传递到开放层的下一层。参考下图示意，就可以解决刚才的那个问题了，即：业务层专属的共享层可以设计为开放层，然后业务层在需要访问持久化层时可以绕开共享，这样就相当合理了吧，嘿嘿。

![Figure 1-3](https://raw.githubusercontent.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/img/software_architecture_patterns_figure1_3.png "Figure 1-3")

基于具有开、闭特性的分层架构很好地诠释了各个层与请求流程的关系，同时也为架构师、工程师很好地理解各层间的访问约束提供了必要的信息。要是不能与架构中具有开、闭特性的各层合理对接，那么肯定会使得整个架构内部是紧耦合的、不健壮的，而且非常难以测试、维护和开发。

##模式实例

图`Figure 1-4`呈现了分层架构的工作原理，即，一个业务员查询客户数据的流程。图中的黑色箭头指示了由上至下获取客户数据的过程，红色箭头指示了数据返回并最终展示的过程。其中，客户数据除了包含客户资料还包含了客户自己产生的订单数据。

**详细分析**

* `Customer Screen`模块负责接收业务员的请求以及显示查询到的客户数据。它并不感知需要查询几个数据库才能最终获取到客户数据，而是只需要负责接收业务员的查询请求，并把请求传递给`Customer Delegate`模块。
* `Customer Delegate`模块负责感知业务层中哪些模块可以处理来自于`Customer Screen`的请求，以及如何与业务层中的相应模块(`Customer Object`)对接（接口协议）。
* `Customer Object`模块负责整合展现层需要的客户数据。它不但要请求持久层里客户资料对应的模块(`Customer DAO`)，还要请求订单数据对应的模块(`Order DAO`)。
* `Customer DAO`模块和`Order DAO`依次执行SQL语句来对数据库进行查询，获取到相应数据后回传给业务层的`Customer Object`模块。一旦`Customer Object`把客户资料和订单数据都获取到，就会整合两部分数据并把整合后的数据回传给`Customer Object`，从而进一步回传给`Customer Screen`模块，最终把查询到的数据展现给业务员。

![Figure 1-4](https://raw.githubusercontent.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/img/software_architecture_patterns_figure1__4.png "Figure 1-4")

从技术实现的角度来看，这些模块有很多不同的技术实现方案。

比如，
	
	在Java平台，Customer Screen可以采用JSF(Java Server Faces)方案，并由Customer Delegate来管理JSF的数据对象。
	业务层的Customer Object可以采用Spring[^]管理的数据对象或EJB3的数据对象来实现。
	持久化层的DAO层(Data Access Objects)可以采用POJO（Plain Old Java Objects）与MyBatis
	或JDBC或Hibernate组合实现。
	
	从微软平台的角度来制定技术实现方案时，Customer Screen模块可以使用.NET框架中的ASP(Active Server Pages)
	来访问业务层里以C#语言开发的子模块，而持久化层的子模块则采用ADO方案（ActiveX Data Objects）。
	
****相关知识点：****Spring[^3]、EJB[^4]<br/><br/>
[^3]: [Spring详细资料](http://www.oracle.com/technetwork/developer-tools/eclipse/springtutorial-087561.html)
[^4]: [EJB详细资料](https://docs.oracle.com/cd/E24329_01/web.1211/e24446/ejbs.htm#INTRO255)

##架构考量

分层架构是一个很稳定的通用架构模式，它可以作为很多应用的一个初始加构，尤其是在你不确定什么的加构适合你的项目的时候。尽管如此，当你在选择此架构模式时，仍然需要注意几点：

**首先**，需要注意的是`污水池反模式`。它描述了这样一种场景，即一个请求经过多层传递却没有执行任何逻辑操作。例如，展现层接受了用户查询客户数据的请求后，然后传递给业务层，再传递到持久化层，持久化层组装相应的查询SQL并传递到数据库层去获取数据。最后，从数据库查询到的数据没有经过任何处理（如整合、运算、数据转换）就一层一层地又回传给展现层。

采用分层架构的应用或多或少地有被沦陷为`污水池反模式`的模块。但是，重要的还是分析应用中沦陷为`污水池反模式`的请求的占比。`28原则`[^5]一直是一个用于检验你的项目是否遭遇了`污水池反模式`的很好的实践，即大概20%的请求只在层与层之间被简单传递，大概80%的请求不仅在层与层被传递同时还有一些相应的逻辑处理。但是，如果你发现这个比率是反过来的，即20%的请求在层间传递且逻辑处理，80%的请求只是在层间传递，那么，这时你就应该考虑做一些开放某些层的工作了，这个工作比管理有隔离缺陷的层的工作更难。

[^5]:[28原则资料](http://baike.baidu.com/view/40591.htm?fromtitle=%E4%BA%8C%E5%85%AB%E5%8E%9F%E5%88%99&fromid=3689905&type=syn)

**其次**，需要考虑的是分层架构模式有把自己大一统的趋势。尽管你已把展现层和业务层拆分成了不同的模块。分层架构的各层代码都归类到了不同的项目开发目录。对于某些应用来说，它并不关注这点，但是这个问题确实会导致开发阶段的很多潜在的问题、健壮性问题、可靠性问题、性能问题以及扩展性问题。

##模式分析
下面的表格中是对分层架构的一些常规特点的评级和分析。每个特性的评级高低取决于它在架构的典型实现方案中能否作为自然趋势的能力，以及它能否能作为分层架构的主要强项。关于几种架构模式的整体比较结果，请参看附录A。

**整体的敏捷性**

	等级：低
	理由：应用程序整体的敏捷性是一种对不断变化的需求快速响应的能力。尽管分层架构的设计会把模块的变化隔离在它对应的层里，但是
	分层架构对这种变化的响应还是显得迟钝和耗时，这是由于大多分层架构的具体实现都比较庞大，况且层里的组件间时常有紧耦合的情况。
	
**部署的简易性**

	等级：低
	理由：由于这种架构模式的分层实现方式，所以应用（尤其是大型应用）的部署成了一个问题。即，应用中的一个小修改就需要重新部署
	整个应用（或重新部署应用的大部分功能），从而导致对应用的部署工作就需要在非工作时间或非工作日来计划、安排和实施。正因为如
	此，这种架构模式不太适合持续集成，从而进一步降低了部署便利性的整体评级。
	
**可测性**

	等级：高
	理由：在这一架构模式中，各功能组件都属于相应的架构层，每层之间相对独立，每层都可以被模拟，从而便于测试。如，可以模拟展现层
	来测试业务层，也可以模拟业务层来测试展现层。
	
**性能**

	等级：低
	理由：虽然很多采用分层架构的应用都能正常运转，但是由于业务请求时常需要跨层访问才能获取到期望的结果，从而使得它不在高性能
	应用的行列。
	
**可伸缩性**

	等级：低
	理由：由于这一架构模式的紧耦合倾向性和庞大性，那么一旦采用了这一架构模式的应用就难于扩展。尽管你可以把逻辑架构层进行拆分
	成物理架构层或把整应用复制到多个结点，但是一旦在应用开发中这样做了，那要干的活就多了。
	
**开发的简易性**

	等级：高
	理由：开发的简易性之所以能获得了一个相对较高的评级，主要是由于这一架构模式被大家所熟知而且从开发层面上来看也不复杂。由于大
	多数公司在进行应用开发时，不同专业技能的人负责不同的模块（前端、服务器、数据库等），所以分层架构模式自然也成为了很多应用开
	发的选择。诸如这种公司内部的沟通方式和组织结构与软件开发模式的联系被概括为康威定律。

相关知识点：康威定律[^6]

[^6]:[康威定律](http://www.kankanews.com/a/2013-03-26/004892183.shtml)

<br/>

#第二章 事件驱动型架构模式
@磊哥 快点。。。。。等你翻译的内容。。。

#第三章 微内核架构模式
微内核模式是一种为基于产品的应用程序而生的架构模式，有时也称它为插件模式。那么，什么是基于产品的应用程序呢？基于产品的应用程序是一种分版本打包和分版本下载的第三方产品。很多公司也开发和发布类似产品级的内部业务程序，有：版本控制、版本日志和可插拔的功能特性。这种情况就适合采用微内核架构模式。微内核架构模式可以让开发者在自己的核心程序基础上开发一些带有扩展性和隔离性的插件。

##模式介绍
微内核架构模式由两大组件构成：分别为**系统内核**和**插件模块集**。即，应用程序的逻辑被分为独立的插件模块集合和基本的核心系统，以提供扩展性、灵活性以及扩展特性和和逻辑的隔离性。`图Figure 3-1`以图说明了一个基本的微内核架构模式结构。

通常，微内核架构模式中的**系统内核部分**是指能使系统正常运转所需要的最少功能的集合。很多操作系统都实现了微内核架构模式，这也是微内核名字的由来。从业务程序的角度讲，**系统内核**通常是指按一定场景、规则或复杂的条件来进行逻辑处理的通用业务逻辑。

![Figure 3-1](https://raw.githubusercontent.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/img/software_architecture_patterns_figure3_1.png "Figure 3-1")

围绕着系统内核的插件模块都是独立于系统内核的，这些插件模块集包含了各种对系统核心功能进行扩展的定制功能、附加特性等等。通常来讲，插件之间也是独立的，不过你也可以设计多个有依赖关系的插件。换句话说，你在设计插件集时，需要保证插件间有很好的通信机制从而使得插件间的依赖最小。

同时，系统内核需要知道围绕它开发的插件哪些是与它可以正常通信的且如何通信。通常，一个常用的方式就是在系统内核依次注册这些插件，可以给每个插件注册诸如插件名称、数据交换协议、通信的数据结构在内的等等信息。比如，给一个税务系统开发一个可以标识出缴纳了高税额的纳税人的插件，那么注册信息就需要插件名称、上行下行的数据结构以及数据传输协议。这个例子中，假如你使用SOAP来做远程调用，那么还需要WSDL这个文件来对调用的服务进行描述。

相关知识点：SOAP[^7], WSDL[^8]

[^7]:[SOAP](https://docs.oracle.com/cd/E23943_01/doc.1111/e10807/c25_wsdl_and_soap.htm)
[^8]:[WSDL](https://docs.oracle.com/cd/E23943_01/doc.1111/e10807/c25_wsdl_and_soap.htm)

插件与系统内核之间可以有用多种方式进行通信，比如：OSGi[^9]、消息机制、远程服务(Web Services)或系统内核直接实例化插件。至于采用哪种方式，这完全取决于你的项目类型(是小型项目还是大型项目)以及项目的部署的方式(是单一服务器部署还是分布式部署)。在此应该明白插件间要必须要保持相对独立。

[^9]:[OSGi](https://www.osgi.org/)

系统内核与插件之间的通信协议规范可以是标准协议也可以是自定义协议。通常在第三方团队开发的插件中可以发现自定义协议，这些自定义协议对于系统内核开发商来说是完全不可控的。在这种不可控的案例中，通常需要在插件的自定义协议与系统内核的标准协议之间建立一个适配器来对两种协议进行相互转换，这样操作后，系统内核的协议就不需要与每个插件协议耦合，只需要建立一个适配器即可。同时，请记住在一开始定义通信协议时就要做好协议的版本控制。

##模式实例

微内核架构模式的最好实践可以说是Eclipse IDE。基础版Eclipse本身是一个很NB的编辑器。不过，当你为它加上各种插件后，它就变得更实用，更NB了。

Web浏览器是另一个很不错的微内核架构模式实践：内容显示和一些扩展功能都不是浏览器的系统内核。

以上两个例子是微内核架构模式基于产品型应用的实践，不过它还可以应用于大量商业程序。在这里咱们可以举个保险公司的索赔处理流程。索赔处理是一个非常复杂的流程，不同的情况都有允许的和禁止的业务逻辑规则。比如某些情况下挡风玻璃被石头子儿砸坏了可以申请免费更换，但是也有不能免费更换的情况。正是这些不同的情况构成了标准的索赔流程。

看到这里不要感到奇怪，因为大多数的理赔应用正是依靠大量的复杂的规则引擎集才能处理各种各样的理赔情况。不过，随着逻辑规则的修改或新增一个简单的逻辑规则都会影响其它现有的规则，这就需要更多的分析人员、开发人员和测试人员参与其中。庆幸地是，微内核模式就能解决刚才提到的大部分问题。

如图`Figure 3-2`中的那一摞文件夹，它描述了索赔流程的系统内核部分。它包含了保险公司处理理赔申请的基本的业务逻辑，当然了，没有包括各公司自己定制一些逻辑规则。从图中可以看到，每个插件的逻辑规则都对应到了系统内核的不同业务场景。这些插件可以采用完全自行开发或引用现成的规则引擎来实现。无论采用什么方案来实现这些插件，这些插件都是独立于系统内核的，即，添加、移除、维护插件时都不会对系统内核和其它插件产生一丁点儿的影响。

![Figure 3-2](https://github.com/Handy-Wang/Handy-Wang.github.io/blob/source/source/_posts/img/software_architecture_patterns_figure3_2.png?raw=true "Figure 3-2")

##模式考量

微内核架构模式有一个优点，就是它能被内嵌到或作为其它架构模式的一部分。比如，当系统中某个模块的功能不太稳定时，你会发现只能用微内核架构模式来解决这种特定的问题，而不能用这个模式来替换原架构模式。在形如这种情况时，你就可以在原有的架构模式(分层架构)里内嵌微服务架构模式。类似地，上一章讲到的事件驱动架构里的事件处理器组件也可以采用微服务架构模式来实现。

刚才提到的微服务架构模式为不断演进的设计和逐渐增加的开发需求提供了大力支持。首先好好地设计一个坚实的系统内核，然后在系统迭代过程中的功能增加和改进行都不需要对系统内核进行改造。

对于那些基于产品需求开发的应用程序，微内核架构模式应该作为架构的首选，特别是对于那些需要发布用户真正需要的新需求、新特性的产品。如果你发现这个架构不适合你的项目需求，你可以把架构方案修改成为更适合项目实际需求的架构方案。

##模式分析
下面的表格是对微内核架构模式各个特点的评级和分析描述。对于以下每个特点的评级是基于它是否能作为行业趋势或是否能作为本架构的代表性来评估的。至于本篇文章的几种架构的详细对比，请参见附录A。

**整体的敏捷性**

	等级：高
	理由：整体敏捷性是指对不断修改的需求的适应能力。对采用微内核架构方案的系统的修改，都是可以采用插件方式来隔离和解耦的。通常，
	大多采用微内核架构的应用程序的系统内核都是趋于稳定的，而且相当强劲、基本不会再修改。
	
**部署的简易性**

	等级：高
	理由：鉴于此架构模式的整体架构，那么插件部分是可以在动行时被动态地追加到系统内核上的（热部署），从而最大程度上减少了服务器
	down机的时长。

**可测性**

	等级：高
	理由：插件模块集可以很方便地被隔离测试，而且系统内核可以在不作任何改动的情况下就可以很容易地模拟出被扩展的插件特性功能。

**性能**

	等级：高
	理由：尽管微内核模式不能被自荐给高性能应用程序，但是，大多用到了微内核模式的应用都能正常地动转，因为你可以定制和简化需要扩展
	的插件功能。JBoss应用服务器就是一个很好的采用了微内核架构的例子：通过插件扩展能力，你可以按需移除那些高消耗的或不需要的插件
	功能，比如：远程访问功能、消息功能以及缓存功能等很消耗内存、高CPU的会拖慢应用程序的插件功能。

**可伸缩怀**

	等极：低
	理由：由于大多基于微内核架构的实现方案都是基于成形的产品应用而且规模较小，这些架构实现通常只是作为产品中的一个单元或模块，
	所以不利于扩展。尽管，在实际的插件模块开发中能做到插件级的伸缩，但，微内核架构并不是已具备整体高伸缩应用程序的首选。

**开发的简易性**

	等级：低
	理由：基于微内核架构模式开发的应用，需要深思熟虑的设计和对接口协议的合理管理，这无疑增加了开发的复杂性。接口协议的版本管理、
	插件的注册机制、插件功能的粒度以及插件与系统内核的通信机制等等内容导致了增加实现微内核架构的复杂度。

相关知识点：JBoss[^10]

[^10]:[JBoss](http://www.jboss.org/)

#第四章 微服务架构模式

待续。。。