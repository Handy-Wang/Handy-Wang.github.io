<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Handy's]]></title>
  <link href="http://Handy-Wang.github.io/atom.xml" rel="self"/>
  <link href="http://Handy-Wang.github.io/"/>
  <updated>2015-12-14T21:32:56+08:00</updated>
  <id>http://Handy-Wang.github.io/</id>
  <author>
    <name><![CDATA[Handy.Wang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[软件架构模式（译）]]></title>
    <link href="http://Handy-Wang.github.io/blog/2015/12/10/software-architecture-patterns/"/>
    <updated>2015-12-10T16:10:37+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2015/12/10/software-architecture-patterns</id>
    <content type="html"><![CDATA[<p>原文：<a href="http://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf">《Software Architecture Patterns》</a></p>

<h1>前言</h1>

<p>对于很多开发人员来说，在着手开发时并没有一套有条理的架构体系来指导他们，这简直是一件太正常的事情了。在没有一套清晰的、经过推敲过的架构体系时，许多开发人员和架构师都遵守所谓的行业标准－分层架构模式（也称之为多层架构），即创建隐式的多层结构，即把只是从源代码角度，把模块的源代码都放在不同的源代码路径下，看似像分层了。但，实际上这种层次架构有诸多问题：模块角色没有清晰地划分，模块职责不明确，模块间的关系不清楚。这种架构通常称之为：<a href="http://www.cin.ufpe.br/~sugarloafplop/mud.pdf">大泥球</a>-架构反模式</p>

<p>缺少有条理的架构的应用通常都是紧耦合的、不健壮的、难以维护的，而且没有清晰的视野感和方向感。所以，非常难以确定这个应用的架构特点，以至于不能全面地理解这个应该系统中各模块的内部逻辑。很难找到与开发和维护相关的诸多基本问题的答案：这个应用具有伸缩性吗？这个应用有什么性能特点？这个应用是否很容易维护？这个应用有什么技术特性？</p>

<p>诸多架构模式可以辅助我们定义应用程序的基本特性和行为。例如，某些架构模式偏向于高可伸缩性，某些架构模式偏向于高度敏捷性。所以，在选择一种适合于某个项目的架构之前，了解不同架构模式的特点、优点和缺点是非常有必要的。</p>

<p>作为一名架构师，你需要经常检验你的架构决策，尤其是在选择某种特别的架构或方案的时候。</p>

<!--more-->


<h1>第一章 分层架构模式</h1>

<p>最常见的架构模式是分层架构模式，也称之为多层架构模式。它是一种适用于大多数<code>Jave EE</code>应用的行业标准，被很多架构师、设计师、攻城师所熟知；它与众多公司传统方式的技术交流和组织结构很对口，从而成为众多业务开发工作的首选。</p>

<h2>介绍</h2>

<p>分层架构模式采用横向划分的方式把的各组件划分到相应的层级里面，每层结构在应用里都担任着特定的角色（比如，视图层负责UI展示、业务逻辑层负责业务逻辑处理）。虽然在分层架构模式的理念里没有强制要求分几层，但是一般分为四层：<strong>展现层、业务层、持久化层和数据库层</strong>（<code>如图Figure 1-1.</code>）。在某些情况下，业务层和持久化层统一合并到业务层，尤其是在持久化逻辑代码（比如：SQL或HSQL）被直接写在业务层的各组件中的时候。所以，一般小型应用只有三层架构，而大型的或更复杂的应用则会有五层或更多层架构。</p>

<p>每层架构在应用中都有着特定的角色和职责。例如，展现层是负责处理处所有界面显示和用户浏览时的逻辑，而业务层是充当处理业务请求相关事宜的角色。每层架构都是围绕它需要处理的特定业务逻辑的本职工作进行抽象的。例如，展现层不需要也不用担心将要显示的数据是从哪儿来的，它只需要负责把得到的数据按一定样式显示正确就行。同理，当业务层从某个地方获取到业务数据后，不需要关心这些数据以什么样的样式或形态显示到屏幕后，它只需要关注从持久层获取数据并对这些按一定的逻辑规则加工就好（比如，数据计算或数据整理工作），然后把最终的数据传递给展示层。</p>

<p><img src="https://raw.githubusercontent.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/img/software_architecture_patterns_figure1_1.png" title="Figure 1-1" alt="Figure 1-1" /></p>

<p>其中，分层架构的重要特性之一是各层架构中的组件分工明确。即，每个组件只会处理它所属那层架构的工作。例如，展现层中的组件只会处理展示逻辑，业务层中的组件只会处理业务逻辑。这种对组件的分门别类就构建成了角色明确、职责分明的分层架构，以及易于开发、测试、管理和维护的应用。所以，各层架构中各个组件的接口功能和作用域的良好定义就显示尤其重要了。</p>

<h2>此类架构的关键理念</h2>

<p><strong><code>封闭性</code></strong>－注意<code>图Figure 1-2</code>中，每层架构的右侧都有一个“CLOSED”标签。这是分层架构中其中一个非常重要的理念－封闭。封闭的分层表示：当请求在多层间传递时，它要经过多层传递才会传递到目标层。例如，从展现层发起一个请求，这个请求首先需要经过业务层，再经过持久化层，才能最终到达数据库层。</p>

<p><img src="https://raw.githubusercontent.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/img/software_architecture_patterns_figure1_2.png" title="Figure 1-2" alt="Figure 1-2" /></p>

<p>然而，为什么不允许展现层直接访问其它的各层（持久层或数据库层）呢？因为按常规思维，展现层直接访问数据库层要比经过多层传递后才能查询或保存数据的效率要高得多呀，为什么呢？这个答案就存在于另一个关键理念之中－每层架构的隔离性。</p>

<p><strong><code>隔离性</code></strong>－每层架构的隔离性是指每层内部的修改不会对其它层造成任何影响：层内的任何改变都被隔离于其它层及相关层(比如，含有SQL的持久层)之外。如果允许展现层直接访问持久层，那么对持久层SQL的修改就会同时影响到业务层和展现层，这样做显示使得应用的各层之间的组件都产生了各种复杂依赖、紧耦合。这样的架构非常难于维护。</p>

<p>隔离还意味着分层架构的每层都是独立的，因此每层都不感知其它层内的逻辑细节。为了能很好的理解隔离理念的强大和重要，那么试想一下这种情况：</p>

<pre><code>在花九牛二虎之力把展现层的技术方案由JSP重构为JSF时，只要展示层与业务层之间的对接协议保持不变(例如，使用某个Model数据结构),
那么业务层是不会受展现层技术方案重构影响的，而且其它层更是完全独立于展现层的界面技术方案的。
</code></pre>

<p><strong><strong>相关知识点：</strong></strong>JSP<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>、JSF<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup><br/><br/>
按以上介绍，当具备封闭性的架构层促成了隔离性的架构层以及层与层之间的修改能达到隔离时，那么是时候可以合理地使一些架构层开放了。例如：你可以给业务层增加一个其内部组件可以访问的且包含了很多通用组件的共享服务层（其内包含了数据、字符串工具类或辅助类和日志类）。其实，创建一个服务层一直是一个非常好的设计，因为这个设计从架构上限定：业务层可以访问共享层，而不是展现层可以访问共享层。如果没有这种分层的架构设计，那么将完全不能从架构上来阻止展现层对共享服务层的访问，而且很难管理这种访问受限的情况。</p>

<p>在上面这个为业务层开放了一个共享服务层的例子中，新的服务层应该处于业务层的下面以表明展现层是不能直接访问共享层的。但是，这样的层次结构有一个问题，即：业务层必须要经过共享服务层才能访问到持久化层，如果真是这样的话，就不合理了。这是分层架构一直存在的一个老问题，不过已经通过创建<strong>具有开放特性的架构层</strong>的方式解决了。</p>

<p>如<code>图Figure 1-3</code>所示，图中的服务层右侧有一个“开放”的绿色标签，说明这一层是具有有开放性的，即上层来的请求可以绕开它，从而请求可以直接被传递到开放层的下一层。参考下图示意，就可以解决刚才的那个问题了，即：业务层专属的共享层可以设计为开放层，然后业务层在需要访问持久化层时可以绕开共享，这样就相当合理了吧，嘿嘿。</p>

<p><img src="https://raw.githubusercontent.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/img/software_architecture_patterns_figure1_3.png" title="Figure 1-3" alt="Figure 1-3" /></p>

<p>基于具有开、闭特性的分层架构很好地诠释了各个层与请求流程的关系，同时也为架构师、工程师很好地理解各层间的访问约束提供了必要的信息。要是不能与架构中具有开、闭特性的各层合理对接，那么肯定会使得整个架构内部是紧耦合的、不健壮的，而且非常难以测试、维护和开发。</p>

<h2>实例分析</h2>

<p>图<code>Figure 1-4</code>呈现了分层架构的工作原理，即，一个业务员查询客户数据的流程。图中的黑色箭头指示了由上至下获取客户数据的过程，红色箭头指示了数据返回并最终展示的过程。其中，客户数据除了包含客户资料还包含了客户自己产生的订单数据。</p>

<p><strong>详细分析</strong></p>

<ul>
<li><code>Customer Screen</code>模块负责接收业务员的请求以及显示查询到的客户数据。它并不感知需要查询几个数据库才能最终获取到客户数据，而是只需要负责接收业务员的查询请求，并把请求传递给<code>Customer Delegate</code>模块。</li>
<li><code>Customer Delegate</code>模块负责感知业务层中哪些模块可以处理来自于<code>Customer Screen</code>的请求，以及如何与业务层中的相应模块(<code>Customer Object</code>)对接（接口协议）。</li>
<li><code>Customer Object</code>模块负责整合展现层需要的客户数据。它不但要请求持久层里客户资料对应的模块(<code>Customer DAO</code>)，还要请求订单数据对应的模块(<code>Order DAO</code>)。</li>
<li><code>Customer DAO</code>模块和<code>Order DAO</code>依次执行SQL语句来对数据库进行查询，获取到相应数据后回传给业务层的<code>Customer Object</code>模块。一旦<code>Customer Object</code>把客户资料和订单数据都获取到，就会整合两部分数据并把整合后的数据回传给<code>Customer Object</code>，从而进一步回传给<code>Customer Screen</code>模块，最终把查询到的数据展现给业务员。</li>
</ul>


<p><img src="https://raw.githubusercontent.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/img/software_architecture_patterns_figure1__4.png" title="Figure 1-4" alt="Figure 1-4" /></p>

<p>从技术实现的角度来看，这些模块有很多不同的技术实现方案。</p>

<p>比如，</p>

<pre><code>在Java平台，Customer Screen可以采用JSF(Java Server Faces)方案，并由Customer Delegate来管理JSF的数据对象。
业务层的Customer Object可以采用Spring[^]管理的数据对象或EJB3的数据对象来实现。
持久化层的DAO层(Data Access Objects)可以采用POJO（Plain Old Java Objects）与MyBatis
或JDBC或Hibernate组合实现。

从微软平台的角度来制定技术实现方案时，Customer Screen模块可以使用.NET框架中的ASP(Active Server Pages)
来访问业务层里以C#语言开发的子模块，而持久化层的子模块则采用ADO方案（ActiveX Data Objects）。
</code></pre>

<p><strong><strong>相关知识点：</strong></strong>Spring<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>、EJB<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup><br/><br/></p>

<h2>架构考量</h2>

<p>分层架构是一个很稳定的通用架构模式，它可以作为很多应用的一个初始加构，尤其是在你不确定什么的加构适合你的项目的时候。尽管如此，当你在选择此架构模式时，仍然需要注意几点：</p>

<p><strong>首先</strong>，需要注意的是<code>污水池反模式</code>。它描述了这样一种场景，即一个请求经过多层传递却没有执行任何逻辑操作。例如，展现层接受了用户查询客户数据的请求后，然后传递给业务层，再传递到持久化层，持久化层组装相应的查询SQL并传递到数据库层去获取数据。最后，从数据库查询到的数据没有经过任何处理（如整合、运算、数据转换）就一层一层地又回传给展现层。</p>

<p>采用分层架构的应用或多或少地有被沦陷为<code>污水池反模式</code>的模块。但是，重要的还是分析应用中沦陷为<code>污水池反模式</code>的请求的占比。<code>28原则</code><sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>一直是一个用于检验你的项目是否遭遇了<code>污水池反模式</code>的很好的实践，即大概20%的请求只在层与层之间被简单传递，大概80%的请求不仅在层与层被传递同时还有一些相应的逻辑处理。但是，如果你发现这个比率是反过来的，即20%的请求在层间传递且逻辑处理，80%的请求只是在层间传递，那么，这时你就应该考虑做一些开放某些层的工作了，这个工作比管理有隔离缺陷的层的工作更难。</p>

<p><strong>其次</strong>，需要考虑的是分层架构模式有把自己大一统的趋势。尽管你已把展现层和业务层拆分成了不同的模块。分层架构的各层代码都归类到了不同的项目开发目录。对于某些应用来说，它并不关注这点，但是这个问题确实会导致开发阶段的很多潜在的问题、健壮性问题、可靠性问题、性能问题以及扩展性问题。</p>

<h2>模式分析</h2>

<p>下面的表格中是对分层架构的一些常规特点的评级和分析。每个特性的评级高低取决于它在架构的典型实现方案中能否作为自然趋势的能力，以及它能否能作为分层架构的主要强项。关于几种架构模式的整体比较结果，请参看附录A。</p>

<p><strong>整体的敏捷性</strong></p>

<pre><code>等级：低
理由：应用程序整体的敏捷性是一种对不断变化的需求快速响应的能力。尽管分层架构的设计会把模块的变化隔离在它对应的层里，但是
分层架构对这种变化的响应还是显得迟钝和耗时，这是由于大多分层架构的具体实现都比较庞大，况且层里的组件间时常有紧耦合的情况。
</code></pre>

<p><strong>部署的便利性</strong></p>

<pre><code>等级：低
理由：由于这种架构模式的分层实现方式，所以应用（尤其是大型应用）的部署成了一个问题。即，应用中的一个小修改就需要重新部署
整个应用（或重新部署应用的大部分功能），从而导致对应用的部署工作就需要在非工作时间或非工作日来计划、安排和实施。正因为如
此，这种架构模式不太适合持续集成，从而进一步降低了部署便利性的整体评级。
</code></pre>

<p><strong>可测性</strong></p>

<pre><code>等级：高
理由：在这一架构模式中，各功能组件都属于相应的架构层，每层之间相对独立，每层都可以被模拟，从而便于测试。如，可以模拟展现层
来测试业务层，也可以模拟业务层来测试展现层。
</code></pre>

<p><strong>性能</strong></p>

<pre><code>等级：低
理由：虽然很多采用分层架构的应用都能正常运转，但是由于业务请求时常需要跨层访问才能获取到期望的结果，从而使得它不在高性能
应用的行列。
</code></pre>

<p><strong>可伸缩性</strong></p>

<pre><code>等级：低
理由：由于这一架构模式的紧耦合倾向性和庞大性，那么一旦采用了这一架构模式的应用就难于扩展。尽管你可以把逻辑架构层进行拆分
成物理架构层或把整应用复制到多个结点，但是一旦在应用开发中这样做了，那要干的活就多了。
</code></pre>

<p><strong>开发的简易性</strong></p>

<pre><code>等级：高
理由：开发的简易性之所以能获得了一个相对较高的评级，主要是由于这一架构模式被大家所熟知而且从开发层面上来看也不复杂。由于大
多数公司在进行应用开发时，不同专业技能的人负责不同的模块（前端、服务器、数据库等），所以分层架构模式自然也成为了很多应用开
发的选择。诸如这种公司内部的沟通方式和组织结构与软件开发模式的联系被概括为康威定律。
</code></pre>

<p>相关知识点：康威定律<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>
待续。。。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="https://docs.oracle.com/javaee/5/tutorial/doc/bnagx.html">JSP详细资料</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnaph.html">JSF详细资料</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://www.oracle.com/technetwork/developer-tools/eclipse/springtutorial-087561.html">Spring详细资料</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p><a href="https://docs.oracle.com/cd/E24329_01/web.1211/e24446/ejbs.htm#INTRO255">EJB详细资料</a><a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p><a href="http://baike.baidu.com/view/40591.htm?fromtitle=%E4%BA%8C%E5%85%AB%E5%8E%9F%E5%88%99&amp;fromid=3689905&amp;type=syn">28原则资料</a><a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
<li id="fn:6">
<p><a href="http://www.kankanews.com/a/2013-03-26/004892183.shtml">康威定律</a><a href="#fnref:6" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015年我都干嘛了]]></title>
    <link href="http://Handy-Wang.github.io/blog/2015/12/06/2015nian-wo-du-gan-ma-liao/"/>
    <updated>2015-12-06T11:33:18+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2015/12/06/2015nian-wo-du-gan-ma-liao</id>
    <content type="html"><![CDATA[<p>2015年即将结束，那这一年我到底都干嘛了？</p>

<pre><code>从去年(2014)的12月份就开始暗无天日的加班忙碌，直到今天下半年才好了很多，眼看这就要要2016了，
也该回顾一下2015年的工作了。
</code></pre>

<h4>AutoLayout</h4>

<p>2015年12月，加入了一个新团队－嗨购，仍然是负责iOS项目开发，人员上加上我两人，版本处于0.0.1版本。</p>

<p>当时接收项目后，发现这个项目的界面采用storyboard+autolayout开发，另外那个哥们去AutoLayout的使用也处于学习阶段，所以遇到的主要问题就是修改界面的Bug。由于我之前没有使用过storyboard和autolayout，再加上UI设计师对界面的细节控制要求很高，所以有些应付不了了。在另一个哥们儿的辅助下，将就着开发了0.1.0版本(仍采用storyboard+autolayout)，其实这个过程非常苦恼，“是好好学习一下AutoLayout，然后在项目里继续使用AutoLayout呢？” 还是 “采用自己熟悉的纯代码方式来编写？”</p>

<!--more-->


<p>最后，综合考虑项目的进度压力、质量的可控性、学习的时间成本后，决定还是暂时放弃Storyboard+AutoLayout，转而使用保守的纯代码方式开发。</p>

<p>在0.1.0版本后，恰逢元旦，另外那个哥们儿休假半个月左右，回家结婚去了。我就逮着这个时机，在项目0.2.0时把项目界面实现方式、网络层、数据库等进行了大重构。</p>

<p>现在相对不忙碌了，计划补补 Todo: <a href="https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/AutolayoutPG/index.html">AutoLayout</a>以及 Todo: <a href="https://github.com/SnapKit/Masonry">Masonry</a>.</p>

<h4>CocoaPods</h4>

<p>其实，上面提到AutoLayout被我弃用后，就感觉比较反人类了，然后我仍然还要反人类一次。</p>

<p>嗨购项目在0.2.0及之前，对第三方库的依赖方式是通过CocoaPods来管理的，但是为什么这之后我把CocoaPods去掉了呢？这就不得不提到Jenkins(我会在后面聊聊Jenkins)和CocoaPods的代码管理。</p>

<p>本来采用Jenkins对iOS项目打包发布是一件很NB的事情，但是对通过CocoaPods管理第三库的iOS项目打包是一件非常痛苦的事情。说起痛苦，主要是集中在Jenkins上的配置以及项目本身的一些配置，如：Jenkins里build目录的指定、项目中schema的share等问题。这一系列问题我都有记录，这里就不细说了。虽然痛若，但是经过两三天的努力，可以通过Jenkins打包CocoaPods管理的项目。</p>

<p>感觉这一点还好，但是，没有想到最后让我放弃CocoaPods的原因尽是它的优点：无感知管理项目的第三方库依赖。
因为，</p>

<ol>
<li>第三方库难免有Bug，所以我也经常修改这些源码里Bug，修改地方多了后也就忘了修改过哪些地方了。然后有一天我pod update了一下，如果本地的源码修改没有了，我得从项目的SVN上对比着再被回来，当时非常恼怒。。。</li>
<li>由于天国的各种墙，安装cocoapods时我修改了gem源为<a href="https://rubygems.org/">https://rubygems.org/</a> . 但是，没有想到在某几天pod update和pod install根本用不了，导致严重影响了我预期的开发进度。</li>
</ol>


<p>所以，我又选择了保守的方案，删除cocoapods，转而采用源代码依赖的方式，这样一来Jenkins打包也简化了。</p>

<pre><code>现在回想，关于那段配置Jenkins打包CocoaPods项目的经历非常可贵，那是对意志的磨砺。
</code></pre>

<ul>
<li><strong>相关知识</strong></li>
<li><a href="https://www.evernote.com/l/AFkw93ypG4JB9Ka-cwCPgU-xtTWZx9RTEa4">Jenkins打包CocoaPods项目</a></li>
<li><a href="http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/">更换CocoaPods的镜像</a></li>
</ul>


<h4>Jenkins</h4>

<p>刚到嗨购的时候，发布安装包的方式是archive ipa文件并上传到fir.im进行发布，以供其它人员进行安装试用或测试。随着项目的推进，期望把这种Inhouse Release的方式自动化，所以引入之前在搜狐时就一直采用的Jenkins进行自动打包发布。</p>

<p>关于Jenkins的安装我简要提一下，主要还是回顾一下使用过程中遇到的问题</p>

<p><strong>Jenkins环境</strong></p>

<ul>
<li>下载Jenkins.war，然后启动java -jar jenkins.war</li>
<li>Jenkins的相关目录

<ul>
<li>/Applications/Jenkins &ndash; which is having the jenkins.war alone.</li>
<li>/Users/Shared/Jenkins &ndash; with all the plugins, war, jobs, usercontent, etc.</li>
<li>/Users/Shared/Jenkins/Home &ndash; JENKINS_HOME</li>
<li>/Library/LaunchDaemons/org.jenkins-ci.plist &ndash; Jenkins自启动文件</li>
<li>/Library/Application Support/Jenkins/jenkins-runner.sh &ndash; 自启动shell脚本</li>
</ul>
</li>
</ul>


<p><strong>Jenkins+CocoaPods项目</strong></p>

<ul>
<li>参见<a href="https://www.evernote.com/l/AFkw93ypG4JB9Ka-cwCPgU-xtTWZx9RTEa4">我的Evenote Sharing</a></li>
</ul>


<p><strong>七牛空间</strong></p>

<ul>
<li>参见<a href="https://www.evernote.com/l/AFkw93ypG4JB9Ka-cwCPgU-xtTWZx9RTEa4">我的Evenote Sharing</a></li>
</ul>


<p><strong>打包状态邮件通知</strong></p>

<ul>
<li>在Jenkins里安装Mail Notification Plugin</li>
<li>以126邮件为例，配置SMPT服务器及端口</li>
<li>注意：Jenkins管理员邮箱要与发送邮件的账号一致，不然会发送邮件失败。</li>
<li>在具体项目中，可以配置相应的收件人、trigger等。</li>
</ul>


<h4>Redmine</h4>

<p>在2008年刚参加工作的时候，老东家就有搭建Redmine用于项目管理、issue跟踪、Wiki书写。在搜狐的时候，是由服务器同学搭建的trac来写wiki。由于刚到嗨购团队的时候，接口文件都是服务器同学通过word文档来记录并分发给相关开发人员。我觉得这样非常的不方便，不但不方便更改，也不便于分发。所以，我偷摸地在公司内网搭建了Redmine，给相关技术人员分发了账号和权限，从而以后<strong>“妈妈再也不用担心我们的接口文档了”</strong>。</p>

<pre><code>Todo: 也有朋友在git上写项目的wiki，改天一定要试下
</code></pre>

<p>到目前为止，我采用过三种搭建Redmine的方法：</p>

<ol>
<li>纯手工24K金方式打造Apache+MySQL+ROR

<ul>
<li>完全手工地安装Apache、MySQL、RubyOnRails环境</li>
<li>此法太虐心，会遇到各种东西没有安装，非常煎熬</li>
</ul>
</li>
<li>采用BitNami一键式安装Redmine

<ul>
<li>采用BitNami安装的Redmine，在一个单独的目录下安装了Apache、MySQL等环境。</li>
<li>BitNami安装Redmine后，操作系统里安装的Apache、MySQL的环境变量被修改了</li>
<li>为了安装一个Redmine，把操作系统里本身配置的一些环境变量给搞乱，不好不好。</li>
</ul>
</li>
<li>布署Redmine项目源码

<ul>
<li>Redmine本身是一个ROR项目，再加上09年左右的时候做过一个ROR项目，所以此法可试。</li>
<li>下载Redmine源码: <a href="http://www.redmine.org/projects/redmine/wiki/Download">http://www.redmine.org/projects/redmine/wiki/Download</a></li>
<li>解压Redmine到某个目录</li>
<li>配置数据库连接，并创建或导入Redmine数据库表</li>
<li>在Redmine项目运行sudo ruby bin/rails server webrick -e production来启动项目，从而抛弃Apache</li>
<li><strong>此法最好，对于我来说最简单直接，也符合程序思维(建立数据库、配置数据连接、部署项目源码并运行)</strong></li>
</ul>
</li>
</ol>


<h4>Push Notification Simulator</h4>

<p>早在搜狐的时候，就遇到推送调试非常不方便的问题。试用了一些方案，但最终于我还是搭建了一套更好的方案，并运用到了搜狐新闻和嗨购项目中。</p>

<p>最开始的方案是采用PushMeBaby，这是一个Mac版的源代码项目，把项目需要收到推送的Dev或Release的push certification导入项目，并设置好相应的宏就可以运行一个Mac App，然后输入相应手机的Token就可以发推送了。</p>

<p>随着我对PushMeBaby的使用，非常想把推送模拟发送机制进行改进，因为我发现它有几个弊端：</p>

<ul>
<li>PushMeBaby的环境建立不方便，因为它是一个Mac环境，需要在开发人员自己的电脑各位持有一位源码并运行。完全没有必要。</li>
<li>PushMeBaby需要配置Push Certificate，这一点估计会难倒不少对iOS开发的PrivateKey、Certificate、Provisioning Profile等授权概念比较混淆的人。门槛有点高。</li>
<li>PushMeBaby只能给某一个PushCertificate发推送。非常不灵活。</li>
<li>PushMeBaby只能输入Token。非常不灵活。</li>
<li>PushMeBaby的推送内容修改只能修改源码。非常不方便。</li>
</ul>


<p>终于，在开发搜狐新闻的<strong>推送打开Navtive页面</strong>这一功能时，由于要反复调试推送内容，所以我决定自己搭一个即保留PushMeBaby已有功能，也可以解决以上问题的推送环境，我给它起了个名字－Push Notification Simulator。</p>

<p><strong>Push Notification Simulator</strong></p>

<ul>
<li>找一台做CI的服务器(肯定是Mac嘛)</li>
<li>Mac自带Apache+PHP环境。大环境就这么轻松的满足了。</li>
<li>开发一个简单的H5页面作为首页

<ul>
<li>具备推送内容的配置功能</li>
<li>具备Push Certificate的选择功能，只需要由一人来上传各Push Certificate即可。</li>
<li>具备Token的选择和手动输入功能</li>
</ul>
</li>
<li>开发一个可以把H5页可编辑内容作为参数来发送推送的PHP文件</li>
<li>运行，测试，好使。</li>
</ul>


<p>在一个团队里，这是一个非常省心的方案。</p>

<h4>Crashlytics &amp; App Log</h4>

<p>App crash给人一种非常重大的事件的感觉，所以早期遇到App crash总是有些菊花一紧的感觉。倒不是说害怕App crash，而是因为环境的限制或者低概念crash而查不到App crash的原因，尤其是在线上版本crash的时候。</p>

<p>目前，友盟、TalkingData等第三方统计平台也都可以借助其SDK上报Crash Log了，但毕竟它们的核心是做统计，其实Crash Log分析远远比不上Crashlytics.</p>

<p><strong>Crashlytics</strong></p>

<p>最开始，Crashlytics作为一个独立项目存在，后被Twitter收购作为Fabric下的一个子项目了。</p>

<p>现在，集成Crashlytics挺方便的：</p>

<ul>
<li>注册 Fabric 账号</li>
<li>安装 Fabric 客户端</li>
<li>按 Fabric 客户端的指引导入 Fabric 和 Crashlitics Framework</li>
<li>在 AppDelegate 中 import Crashlytics，并初始化 SDK</li>
<li>添加 RunScript。我会判断不是 Debug Configuration 时才上报 Crash Log。Debug Configuration 下的crash 一般都好解决，因为这时还处于开发环境；而 Release 或 Release-Inhouse 已处于 Distribution 环境了。</li>
</ul>


<p>在 Crashlytics 网站后台可以很方便的分App、分版本的查看不同时间段的 Crash Log，并且还可以在 App 内使用Crashlytics 来输出特定的日志或标记，以便在Crashlytics 网站后台查看 Crash Log 时可以更好的跟踪 Crash 原因。</p>

<p><strong>App Log</strong></p>

<p>Crashlytics偏技术，重点在于解决Crash。</p>

<p>但是，App发版以后，可能仍存在一些逻辑漏洞没有被测试出来，比如页面上的数据展现效果很奇怪、页面间某些衔接逻辑有些混乱了，类似的这一类问题属于业务问题。当在App发版后，发生业务Bug且开发人员很难通过Review自己的代码来查找Bug时，就需要借助服务器日志或App日志。</p>

<p>我在嗨购项目里尝试写一个上传代码日志的逻辑，原理很简单：</p>

<ul>
<li>把App内的NSLog输出的日志重定向输出到一个文件并保存起来</li>
<li>每次App EnterBackground时，启动一个BackgroundTask线程检查日志文件是否大于1M了，如果大于1M则上传到服务器，上传成功则删除日志文件</li>
<li>此日志文件不纳入App缓存管理的范畴</li>
</ul>


<p>另看，这一小小的机制，在后来辅助修改业务Bug起到了大作用。</p>

<pre><code>Crashlytics &amp; App Log已作为我经手的项目的常规架构支持。
</code></pre>

<h4>嗨购项目架构演进概要</h4>

<p>技术架构，这一词给我的印象一直是既清晰又模糊，并不断地刷新它在我心目中的概念。</p>

<h6>何谓清晰</h6>

<p>从08年工作至今，同事经常会聊天技术架构、网络上经常看到技术架构各种概念，有些人或网站能说得头头是道，有些却说个大概，总之，耳濡目染地能清晰地感受到技术架构是一件很NB的事儿。</p>

<h6>何谓模糊</h6>

<p>从刚工作几年时，在内心就萌芽了架构师的梦想，但是真正在向这个方向努力的时候我却在问自己一个问题：“什么是架构？什么是架构师？好的架构师如何来做好的架构？”，所以，架构一词就像隐形的空气里，明明能感觉到离你很近，但是却摸不着看不见，有一种无从下手的感觉。</p>

<h6>学习之路</h6>

<p>这几年工作下来，通过自我的学习，与同事、朋友的交流，工作的实践，以及阶段性的总结，有了自己一个循序渐进地对架构的理角：</p>

<p><strong>重构</strong> － 从在搜狐工作开始，我开始培养自己的程序设计能力，以及对程序结构的理解。那时，我对架构的理解是从代码重构过渡过去的，即，好的架构就是代码整洁、逻辑清晰。所以，那时我必须让自己按这个要求去做，以致于现在都有了代码洁癖之类的强迫证。</p>

<p><strong>抽像模块</strong> － 随着开发工作的进展，我发现很多功能、逻辑模块是可以复用地，但是好像很多人愿意Copy &amp; Paste代码，因为这样写代码很快。其实，到最后得不偿失，你会发现最后代码失控了、到处打补丁、一个很小的Bug都要费九牛二虎之力才能Fix。所以，我必须多花一两个小时或一两天的时间把我觉得应该重构、抽像、解耦的模块进行修改，然后再在此基础上做相应的业务。</p>

<p><strong>分层、职责专一</strong> － 后来，打算从搜狐离职了，去腾讯面试，我现在都还清楚地记得人家问了我一个问题：“搜狐新闻App iOS版里有没有你们自己设计的一些架构？”，我当然说有啊，但是经过我描述我所理解地以及在搜狐新闻App中看到的所谓的架构后，人家说他想要的不是这个。</p>

<blockquote><h6>我当时大致是这样描述搜狐新闻App的架构的：UIViewController作为控制器发起网络请求，网络请求由Service负责，Service另还负责网络请求获取到的JSON数据解析，最后把解析好的数据返回给上层。其实，现在再回过头去Review之前的代码，还有诸多设计问题。</h6></blockquote>

<p>我例举此经历其实是为了举出这个反例。因为后来我对架构有了新的理解－分层设计以及专一职责这两大概念。经过，后来我的反思、反问自己：“这个哥们儿期望的架构应该是怎样的？什么叫自己设计过的架构？”，我有了对架构新的理解：App架构(以及别的领域)不是把诸多纯粹的代码模块、第三方库、数据等像堆积木一样简单直接地拼凑而成（尽管可能它们之间是独立的、解耦的、易用的），也不是简单地套用被大家都说烂了的MVC（就如上面我在腾讯面试时陈述的那样）。后来，我又review了之前搜狐新闻App的代码，确实发现了诸多问题，如：（只列举一二，开始自己扇自己脸了）</p>

<ul>
<li>过渡依赖TT框架</li>
<li>View里居然发起网络请求</li>
<li>过渡依赖数据库，以致数据库迁移方案同样不简单</li>
<li>数据库操作需要写SQL（对于之前不会SQL的同事来说是灭顶之灾，哈哈哈）</li>
<li>等等，我狠狠的扇了自己几下，算了不说了。</li>
<li><strong>BTW：我这是过于自惭形秽了，其搜狐新闻客户端App里很多我现在在用以及非常受益的思考和代码。</strong></li>
</ul>


<p>在我加入嗨购后，我仍然在反思那哥们儿的问题，同时更激进地去查阅别人对App架构的观点或理解，慢慢地我有一了一套我自己设计的<strong>基于Layered Architecture的iOS App架构</strong>：（简单描述如下，而后我会<a href="">另起一文来阐述我的理解－待续</a>）</p>

<ul>
<li>View Layer</li>
<li>URLPath Based Controller Layer</li>
<li>DataCenter Layer</li>
<li>APIManager Layer</li>
<li>PersistenceManager Layer</li>
</ul>


<p>同时，从跨业务、跨App的角度，我把这套架构设计又划分为：</p>

<ul>
<li>Business Layer －开发人员主要关心的</li>
<li>Business Support －开发人员大部分不用关心的</li>
<li>Tech Support －开发人员完全不用关心的</li>
</ul>


<p>以上两种分层的方式都涉及到里面非常多的技术点和坑，我还是<a href="">另起一文来阐述我的理解－待续</a></p>

<p><strong>跨业务/跨App</strong></p>

<p>目前，在嗨购团队开发出来三个App基本都采用了上面我设计的这种架构，而且对于某些类我已配置了Xcode代码模板，用起来非常方便。这套架构设计最大的益处就是开发人员可以把主要的精力集中在业务层面，对于技术以及可复用的业务层面代码基本上都已经被抽离出来了。当然，它仍然还在改进中、细化中，比如：View层的事件驱动，持久层的泛化等等。</p>

<p><strong>可约定地、可传承地、固定且逐渐演进的开发模式</strong></p>

<p>从在搜狐期间工作到现在来到创业团队奋斗，我一直在不断的摸索、学习、反问自己什么是架构，什么是好的架构，没有人来手把手的教你、告诉你从哪儿学习、该怎么做，不过没有关系，我想说的是即使别人在你的头上开个孔，然后把他知道的一切灌进去也是无用的，因为很多细节需要积累、需要自己反思和总结。只有你经过摸索、学习、总结后，尽管自己的设计、观点是错的，但是在与别人切磋、讨论时很容易理解别人的观点，以及辩证地看待优劣、好坏。</p>

<p>所以，如果我觉得我的程序或架构设计成果还行，那么我会第一时间把它分享给我的队友，首先是阐述我的思想、然后说服他们接受我的架构，如果说服了那么在思想上就达成一致了，那么在以后的执行层面就不是问题了，队友们就可以帮我传递这些设计并且会即时反馈缺点以便我修正。</p>

<p>现在，我们队员间相互Review代码时，只需关注在业务层面以及一些新增的有意义的技术点，而不是纠结在队员对技术观点、代码风格等等无休止的争论上。</p>

<p>最后，我建议：作为一名软件技术人员，我们要不断的探索、学习、实践，最后一定不要忘了总结，把自己的切身体会和理解抽象成一套属于自己原创的有体系结构的技术方法论。</p>

<p>所以，越学习越发现自己的知识很贫瘠，我仍需要大量的学习，也正在学习中&hellip;..Fighting!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何重置推送设置提醒(转)]]></title>
    <link href="http://Handy-Wang.github.io/blog/2014/03/27/ru-he-zhong-zhi-tui-song-she-zhi-ti-xing/"/>
    <updated>2014-03-27T12:33:35+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2014/03/27/ru-he-zhong-zhi-tui-song-she-zhi-ti-xing</id>
    <content type="html"><![CDATA[<h6>步骤很简单，就是有点麻烦。如下：</h6>


<pre><code>1 删除app
2 重启
3 设置里修改系统时间为至少1天后
4 重启，重新安装app，打开app，就能再次看到“是否允许推送”确认框
5 把系统时间调回正常当前时间即可(这一点是为了保证时间的正常使用与推送无关)
</code></pre>

<h3>参考</h3>


<p><a href="http://stackoverflow.com/questions/2438400/reset-push-notification-settings-for-app">http://stackoverflow.com/questions/2438400/reset-push-notification-settings-for-app</a><br />
<a target="_blank" href="http://weibo.com/danc?topnav=1&wvr=5&topsug=1">@Dan</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剖析带有afterDealy参数的performSelector方法实现]]></title>
    <link href="http://Handy-Wang.github.io/blog/2014/03/19/pou-xi-performselectordai-you-afterdealy-can-shu-de-fang-fa-shi-xian/"/>
    <updated>2014-03-19T15:46:02+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2014/03/19/pou-xi-performselectordai-you-afterdealy-can-shu-de-fang-fa-shi-xian</id>
    <content type="html"><![CDATA[<p>主要从performSelector:afterDealy:的实现原理来分析为什么在主线程中调用此方法后不会阻塞主线程里业务代码的顺序执行。</p>

<!--more-->


<p>示例代码如下：</p>

<pre><code>- (void)doSomething {
    NSLog(@"Begin doSomething...");
    for (int i = 0; i &lt; 10; i++) {
        if (i == 5) {
            NSLog(@"++++++++++%f", CFAbsoluteTimeGetCurrent());
            [self performSelector:@selector(printIData:) withObject:@(i) afterDelay:0.2];
        }
        else {
            [NSThread sleepForTimeInterval:0.2];
            [self printIData:@(i)];
        }
    }
    NSLog(@"Finish doSomething...");
}

- (void)printIData:(NSNumber *)i {
    int iv = [i intValue];

    if (iv == 5) {
        NSLog(@"===================i is %d, %f", iv, CFAbsoluteTimeGetCurrent());
    }
    else {
        NSLog(@"i is %d, %f", iv, CFAbsoluteTimeGetCurrent());
    }
}
</code></pre>

<p>[[AboutRunloop sharedInstance] doSomething];</p>

<p>输出的结果是：<br/>
2014-03-19 14:44:26.054 RuntimePractice[9750:60b] i is 0, 416904266.054601<br/>
2014-03-19 14:44:26.256 RuntimePractice[9750:60b] i is 1, 416904266.256110<br/>
2014-03-19 14:44:26.457 RuntimePractice[9750:60b] i is 2, 416904266.457738<br/>
2014-03-19 14:44:26.659 RuntimePractice[9750:60b] i is 3, 416904266.659130<br/>
2014-03-19 14:44:26.860 RuntimePractice[9750:60b] i is 4, 416904266.860487<br/>
2014-03-19 14:44:26.861 RuntimePractice[9750:60b] ++++++++++416904266.861006<br/>
2014-03-19 14:44:27.061 RuntimePractice[9750:60b] i is 6, 416904267.061459<br/>
2014-03-19 14:44:27.263 RuntimePractice[9750:60b] i is 7, 416904267.263020<br/>
2014-03-19 14:44:27.464 RuntimePractice[9750:60b] i is 8, 416904267.464554<br/>
2014-03-19 14:44:27.666 RuntimePractice[9750:60b] i is 9, 416904267.666095<br/>
2014-03-19 14:44:27.666 RuntimePractice[9750:60b] Finish doSomething&hellip;<br/>
2014-03-19 14:44:27.672 RuntimePractice[9750:60b] =====i is 5, 416904267.672478<br/></p>

<p>通过示例代码充分说明了：
在主线程中调用performSelector:afterDealy方法后不会阻塞主线程里业务代码的顺序执行。</p>

<p>分析(主线程中调用)：带有afterDealy:参数的performSelector方法内部采用了timer实现，我们知道timer不放到runloop里的话timer是不会触发的，所以这个timer肯定会放到runloop里，又因为主线程的runloop默认是运行着的，所以这个timer一定会被触发即Selector会被runloop触发回调。</p>

<p>回到示例程序上下文里面，当i==5时，执行了performSelector:afterDealy，所以此时一个timer源会被添加加到主线程的runloop里。又根据示例代码的日志输出可以看到doSomething 方法完全执行完后 runloop才触发i==5时的selector调用，这说明在线程中(包括主线程)是先执行线程的代码逻辑，最后才会检测Runloop里有没有注册的监听源，如果有则检测是不是应该触发源对应的外部处理方法，所以最后才会触发i==5的performSelector:afterDealy。</p>

<p>另注：<br/>
1) 示例代码中非i==5的情况下故意sleep了0.2秒(6/7/8/9 4个数x0.2 > delay的0.2)，这是为了充分证明[self performSelector:@selector(printIData:) withObject:@(i) afterDelay:0.2];一定是在doSomething 方法执行完返回后再运行的。<br/>
2) [self performSelector:@selector(printIData:) withObject:@(i) afterDelay:0.2];中的0.2秒按timer的时间触发原理，它是Timer被加到runloop里后的0.2秒，但是在本示例代码环境下，线程里有长时任务正做着，所以这个触发的时间点是从timer被加到runloop里开始计时，等长时任务做完后的最近的0.2秒整数倍的时间点。</p>

<p>综上，performSelector带有afterDealy:参数的方法，哪怕是delay为0，也在当前线程的runloop里注册一个timer源，等线程里的逻辑做完后，会去检测runloop并按runloop里源注册的条件触发对应的事件处理方法，所以这个方法簇不会阻塞原线程中的代码执行流程。</p>

<p>参考：<br/>
1）方法的说明:：NSObject Reference里performSelector:withObject:afterDelay:<br/>
2）Runloop相关： <a href="http://www.hrchen.com/2013/06/multi-threading-programming-of-ios-part-1/">http://www.hrchen.com/2013/06/multi-threading-programming-of-ios-part-1/</a><br/>
3）Timer和Runloop相关： <a href="http://www.hrchen.com/2013/07/tricky-runloop-on-ios/">http://www.hrchen.com/2013/07/tricky-runloop-on-ios/</a><br/>
4）Timer的触发: <a href="http://www.cnblogs.com/smileEvday/archive/2012/12/21/NSTimer.html">http://www.cnblogs.com/smileEvday/archive/2012/12/21/NSTimer.html</a><br/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅谈内存布局(Memory Layout)即虚拟地址空间]]></title>
    <link href="http://Handy-Wang.github.io/blog/2014/03/18/qian-tan-nei-cun-bu-ju-memory-layout/"/>
    <updated>2014-03-18T15:14:37+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2014/03/18/qian-tan-nei-cun-bu-ju-memory-layout</id>
    <content type="html"><![CDATA[<p>对于高级语言的程序员(Java、OC)来说，一定听过堆栈、数据段、代码段，但可能没有细细研究过。本文在此分享对它们的理解。</p>

<!--more-->


<h3>C语言的内存布局</h3>


<p>   这里从C语方入手,说说内存布局。<br/>
<img src="https://raw.github.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/Memory-Layout-300x255.gif" width="400" height="300"><br/>
   内存从低地址到高地址划分，分为：Text Segment、Initialized Data Segment、Uninitialized Data Segment、Heap、Stack。<br/></p>

<h6>Text Segment</h6>


<pre><code>即代码段(Code Segment)，里面存放可执行的指令，可以理解为程序的实际逻辑代码(不考虑形参、局部变量)，不过在代码段里的指令应该已是汇编指令了。
代码段在内存布局中处在堆栈下面(即低地址段)的位置，防止代码段被堆栈溢出覆盖。通常，代码段里的内容是被共享且只读的，防止程序意外的修改其在代码段里的指令。
</code></pre>

<h6>Initialized Data Segment</h6>


<pre><code>即数据段(Data Segment)，这应该是一种狭义的叫法，也就是大家通常意义上认为的数据段。
其实Initialized Data Segment和Uninitialized Data Segment合起来可以称为广义的数据段，因为它们都存数据。
Initialized Data Segment存储被程序员显式初始化过的全局变量、静态变量、常量,由此可以看数据段(狭义)可以进一步的分为 只读区段 和 读写区段，
数据段不是只读的，在程序运行的时候存储在此区段的变量值可以修改。
</code></pre>

<h6>Uninitialized Data Segment</h6>


<pre><code>又名BSS，即Block Started by Symbol，最早是联合航空公司的联合航空符号汇编程序里的一个伪操作，后来BSS这个术语被合并到FORTRAN汇编程序里。
这伪操作定义了一个标签而且预留了一定量的未初始化的区域，所以BSS就成了“单独保留许多独立的小数据的位置“的简称。
由此看出，BSS这部分空间是预留出来的，存放的是程序员没有初始化或初始化为0(我的理解是初始化为nil)的全局变量、静态变量，未初始化的在被编译器在内存中初始化为0(0x0)，
这就是为什么它也叫Uninitialized Data Segment。
[Historically, BSS (from Block Started by Symbol) was a pseudo-operation in UA-SAP (United Aircraft Symbolic Assembly Program), 
the assembler developed in the mid-1950s for the IBM 704 by Roy Nutt, Walter Ramshaw, and others at United Aircraft Corporation.
The BSS keyword was later incorporated into FAP (FORTRAN Assembly Program), IBM's standard assembler for its 709 and 7090/94 computers. 
It defined a label (i.e. symbol) and reserved a block of uninitialized space for a given number of words (Timar 1996). 
In this situation BSS served as a shorthand in place of individually reserving a number of separate smaller data locations. 
Some assemblers support a complementary or alternative directive BES, for Block Ended by Symbol, 
where the specified symbol corresponds to the end of the reserved block.]
</code></pre>

<h6>Heap</h6>


<pre><code>堆区紧接着BSS段，它的内存分配增长方向是从低地址向高地址。所有动态的内存分配操作都是由 程序员 通过相关函数从堆区进行分配和释放，如malloc, realloc, and free这些操作。
在一个进程里，堆区被所有的共享函数库和动态加载的模块所共享。
</code></pre>

<h6>Stack</h6>


<pre><code>栈区紧挨着堆区，一般都处在内存的高地址区域，但是它的内存分配增长方向是从高地址向低地址，也就是说堆和栈的内存分配增长方向上是相对的，即从两头向中间方向。
此区段的内存分配是由编译器做的，当栈顶指针已经遇到堆指针的时候表明栈溢出了。
栈区是LIFO的结构，SP(Stack Pointer)寄存器始终记录着栈顶位置，当push或pop数据的时候，SP都会有相应的变化。
在栈区里主要是存放函数调用相关的内容，如：实参、函数调用的返回地址、局部变量等相关信息，我们称之为栈帧(Stack Frame)，
也就是说在栈区里有很多个栈帧，每进行一次函数调用，一个新的栈帧就会入栈，且向低地址区方向增长。
一个栈帧至少由一个函数调用的返回地址组成，所以普通的函数调用递归函数调用都是借助这个返回地址才得到让程序流程进行下去的。
The stack frame at the top of the stack is for the currently executing routine. The stack frame usually includes at least the following items (in push order):
the arguments (parameter values) passed to the routine (if any);
the return address back to the routine's caller (e.g. in the DrawLine stack frame, an address into DrawSquare's code); and
space for the local variables of the routine (if any).
</code></pre>

<h6>C语言函数调用的内存机制</h6>


<pre><code>待续。。。
</code></pre>

<h3>C++语言的内存布局</h3>


<p>C++的内存布局大致分为：代码段、全局/静态存储区、常量区、自由存储区、堆、栈。</p>

<h6>差异</h6>


<pre><code>1）全局/静态存储区
    全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，
    在C++里面没有这个区分了，他们共同占用同一块内存区（未初始化的变量都被初始化成0或空串，C中也一样）。
2）常量存储区
    这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。
    注意常量的存放区域，通常情况下，常量存放在程序区(程序区是只读的，因此任何修改常量的行为都是非法的)，而不是数据区。
    有的系统，也将部分常量分配到静态数据区，比如字符串常量(有的系统也将其分配在程序区)。但是要记住一点，常量所在的内存空间都是受系统保护的，不能修改。
    对常量空间的修改将造成访问内存出错，一般系统都会提示。常量的生命周期一直到程序执行结束为止。
3）自由存储区
    就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的
5）重要示例：
    char s[]="123";    s在栈区，“123”在栈区，其值可以被修改
    char *s="123";     s在栈区，“123”在常量区，其值不能被修改
</code></pre>

<h3>OC语言的内存布局</h3>


<pre><code>减少内存垃圾碎片的优化: 《Pro Multithreading and Memory Management for iOS and OS X》中The alloc Method小节1-7图
</code></pre>

<p>待续。。。</p>

<p><a href="http://reverse.put.as/wp-content/uploads/2011/06/objective-c-internals.pdf">http://reverse.put.as/wp-content/uploads/2011/06/objective-c-internals.pdf</a>
<a href="http://www.cnblogs.com/csutanyu/archive/2011/12/12/Objective-C_memory_layout.html">http://www.cnblogs.com/csutanyu/archive/2011/12/12/Objective-C_memory_layout.html</a>
<a href="http://www.easyfunstudy.com/books/Transfer/Learning_Objective_C_2_0__A_Hands_On_Guide_to_Objective_C_for_Mac_and_iOS_Developers__Developer__039_s_Library_.pdf">http://www.easyfunstudy.com/books/Transfer/Learning_Objective_C_2_0__A_Hands_On_Guide_to_Objective_C_for_Mac_and_iOS_Developers__Developer__039_s_Library_.pdf</a></p>

<h6>差异</h6>


<p>结束语：
究其细节，其实，没有什么过程是“自动的”，这只不过用来搪塞程序员自己的理由。</p>

<h3>参考</h3>


<p>MemoryLayoutOut：<a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/">http://www.geeksforgeeks.org/memory-layout-of-c-program/</a><br/>
DataSegment(wikipedia)：<a href="http://en.wikipedia.org/wiki/Data_segment">http://en.wikipedia.org/wiki/Data_segment</a><br/>
CallStack(wikipedia)：<a href="http://en.wikipedia.org/wiki/Call_stack">http://en.wikipedia.org/wiki/Call_stack</a><br/>
C/C++堆、栈及静态数据区详解：<a href="http://www.cnblogs.com/hanyonglu/archive/2011/04/12/2014212.html">http://www.cnblogs.com/hanyonglu/archive/2011/04/12/2014212.html</a>
C++内存分配、函数调用： <a href="http://www.cnblogs.com/dolphin0520/archive/2011/04/04/2005061.html">http://www.cnblogs.com/dolphin0520/archive/2011/04/04/2005061.html</a><br/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UINavigationController分析]]></title>
    <link href="http://Handy-Wang.github.io/blog/2014/03/14/uinavigationcontrollerfen-xi/"/>
    <updated>2014-03-14T18:55:47+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2014/03/14/uinavigationcontrollerfen-xi</id>
    <content type="html"><![CDATA[<h3>UINavigationController结构</h3>


<p>导航条层次结构<br/>
UINavigationController &ndash;(1:1)&ndash;> UINavigationBar &ndash;(1:多)&ndash;> UINavigationItem &ndash;(1:多)&ndash;> UIBarButtonItem &ndash;(1:1)&ndash;> CustomView<br/>
其中UINavigationBar是UIView的子类，UINavigationItem和UIBarButtonItem都是NSObject的子类，也就是说UINavigationItem和UIBarButtonItem都是
UINavigationBar用于显示的model数据。</p>

<!--more-->




<h6>UINavigationBar与UINavigationItem</h6>


<pre><code>UINavigationBar与UINavigationItem是一对多的关系，UINavigationItem存放UINavigationBar用于显示的数据(title, UIBarButtonItem等)。
UINavigationBar提供 push和pop UINavigationItem的方法,push UINavigationItem后UINavigationBar显示样式对应于新push的UINavigationItem,
上一个UINavigationItem显示成当前UINavigationBar样式的返回按钮以表示回到上一个UINavigationItem。pop 操作与push操作相反，不再赘述。
下面是UINavigationBar中相关的push/pop UINavigationItem的方法：
- (void)pushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated;
- (UINavigationItem *)popNavigationItemAnimated:(BOOL)animated; // Returns the item that was popped.

如果你尝试在UINavigationController的UINavigationBar上push或pop UINavigationItem，那么程序会crash，如下：
"Cannot call pushNavigationItem:animated: directly on a UINavigationBar managed by a controller."
说明UINavigationController自己管理的UINavigationBar不让程序员手动去push和pop UINavigationItem。

试想一下，如果程序员自己实例化一个UINavigationBar，再在其上push和pop UINavigationItem，这样就不会crash了吧？
没错， 是这样的，如下：
- (void)viewDidLoad {
    __navigationBar = [[UINavigationBar alloc] initWithFrame:CGRectMake(0, 0, 320, 44)];   //设置导航栏界面
    UINavigationItem *navigationItem = [[UINavigationItem alloc] initWithTitle:@"登录"];  //初始化并设置title
    UIBarButtonItem *rightBarbutton = [[UIBarButtonItem alloc] initWithTitle:@"注册" style:UIBarButtonItemStyleBordered target:self action:@selector(signin)];
    navigationItem.rightBarButtonItem = rightBarbutton;
    [navigationBar pushNavigationItem:navigationItem animated:YES];
    [self.view __navigationBar];
}

- (void)signin {
    UINavigationItem *navigationItem = [[UINavigationItem alloc] initWithTitle:@"注册"];  //初始化并设置title
    [__navigationBar pushNavigationItem:navigationItem animated:YES];
}
运行的效果和我们采用UINavigationController push和pop的效果一样，只是没有了UIViewController参与。

再试想一下，如果程序员自己来实现UINavigatioinController，那么上面这个利用UINavigationBar push UINavigationItem的环节肯定少不了，
只是另外还要管理UINavigationItem与UIViewController的对应关系、UIViewController类似于UINavigationItem的push/pop、UIViewController stack中每一个的生命周期。
</code></pre>

<h6>UINavigationController与UIViewController与UINavigationItem</h6>


<pre><code>从上一点的分析中已经能大致推测出UINavigationController里肯定有一个UINavigationBar，查看UINavigationController的.h文件也证实了这一点，
所以UINavigationController push/pop UIViewController时，肯定会管理UINavigationItem在UINavigationBar上的pop/push。

那么UINavigationController里管理的UINavigationItem从哪里来呢，以及UIViewController与UINavigationItem的对应关系是怎么样的呢？
    通过查看UIViewControlelr以及UIViewController (UINavigationControllerItem),可以知道
    UIViewControlelr它有一个叫_navigationItem的实例变量，UIViewController (UINavigationControllerItem)中扩展了一个navigationItem属性，
    应该就是访问_navigationItem实例变量。所以，不难推测出UINavigationController push UIViewController时
    UIViewController的View会被用于显示，UIViewController的UINavigationItem会被对应于UINavigationBar的显示，
    并且UINavigationItem被放到UINavigationBar中管理。

UINavigationController也提供了类似于UINavigationBar push/pop的方法，如下：
// Uses a horizontal slide transition. Has no effect if the view controller is already in the stack.
- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;
// Returns the popped controller.
- (UIViewController *)popViewControllerAnimated:(BOOL)animated;
</code></pre>

<h6>导航条的定制</h6>


<pre><code>- (instancetype)initWithNavigationBarClass:(Class)navigationBarClass toolbarClass:(Class)toolbarClass NS_AVAILABLE_IOS(5_0);
</code></pre>

<h6>UIBarButtonItem定制</h6>


<pre><code>- (id)initWithCustomView:(UIView *)customView;
</code></pre>

<h6>子ViewController层次结构</h6>


<pre><code>UINavigationController -(1:多)-&gt; UIViewController -(1:1)-&gt;UINavigationItem
</code></pre>

<h3>子view controller stack的管理</h3>


<p>待续。。。</p>

<h3>子view controller的生命周期和内存的管理</h3>


<p>待续。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIWebView的cookie]]></title>
    <link href="http://Handy-Wang.github.io/blog/2014/03/14/uiwebviewde-cookie/"/>
    <updated>2014-03-14T17:18:03+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2014/03/14/uiwebviewde-cookie</id>
    <content type="html"><![CDATA[<h3>场景描述</h3>


<p>我们以实际例子驱动的方式来开始这个话题。<br />
实际例子描述：在App里内嵌一个UIWebView，通过UIWebView打开<a href="http://weibo.com">http://weibo.com</a> 微博首页，在UIWebView里登录我的账号，登录成功后kill App，再次启动App打开UIWebView时微博仍为登录状态。<br />
实现这个Demo的整体业务代码很简单，主要是怎么实现“再次启动App打开UIWebView时微博仍为登录状态”。这就涉及到UIWebView的cookie问题。</p>

<!--more-->




<h3>Session、Cookie</h3>


<p>客户端(包括浏览器)连接某网站(服务器)进行数据交换时，服务器给客户端分配一个数据交换的环境，保存着相关的状态(登录状态、记住用户名密码等)，称之为会话即Session，每个Session都会有唯一的session id。
在客户端(包括浏览器)不断开连接的情况下这个session会一直在服务器保持着，直到连接断开或会话建立的过程长时间没有数据交换即超时。
Session是客户端第一次请求时在服务器创建的，Session维持的过程中(未断开连接)，客户端肯定会发起多次数据请求，那么对同一服务器的多次请求时，服务器怎么知道各个请求是否是属于同一Sessioin的呢？
这时需要客户端的辅助，这个辅助机制称之为Cookie机制，浏览器的cookie机制都是这么做的，我详细说一下：客户端收到服务器的第一次响应时，服务器会把session id通过response返回给客户端，
客户端收到这个session id后把它存在客户端本地，以后客户端所有向服务器发起的请求都要带着这个session id，
这样服务器就知道这些请求都是属于同一个session，那么这些请求都可以共享这个Session状态(登录状态、记住用户名密码等)。
所谓Cookie就是存在本地的若干数据，如session id等其它一些需要临时存在本地以后请求需要的数据。
所以，一个Session对应一个session id，一个Session对应多个request, 一个request对应多个cookie，session id可以做为其中的一个cookie。</p>

<p>另外，我们还会遇到浏览器的Cookie被禁用的情况(即浏览器不支持存cookie)。这种情况下，对网站的所有请求都必须在url里带着session id，以前是浏览器自动把session id放到请求的header里的。
对于这一点我就不深究了。</p>

<h3>实际例子的解决方案</h3>


<p>在UIWebView里登录成功后，把Session id作为cookie保存到客户端本地，以后对微博网站的所有请求都把存在本地的session id这个cookie传给服务器。代码如下</p>

<pre><code>第一部分
[self restoreCookieIfNeeded];
[self.webView loadRequest:request];

第二部分
- (void)webViewDidFinishLoad:(UIWebView *)webView {
    [self saveSessionIDCookie];
}

第三部分
- (void)saveSessionIDCookie {
    NSArray *nCookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies];
    NSHTTPCookie *cookie = nil;
    for (id cObj in nCookies) {
        if ([cObj isKindOfClass:[NSHTTPCookie class]]){
            cookie = (NSHTTPCookie *)cObj;
            if (!!cookie &amp;&amp; [cookie.name isEqualToString:PHPSESSID]) {
                NSString *savePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES) objectAtIndex:0];
                NSString *saveFile = [savePath stringByAppendingPathComponent:PHPSESSID];
                [NSKeyedArchiver archiveRootObject:cookie toFile:saveFile];
            }
            NSLog(@"cookie properties: %@", cookie.properties);
        }
    }
}

- (void)restoreCookieIfNeeded {
    NSString *savePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES) objectAtIndex:0];
    NSString *saveFile = [savePath stringByAppendingPathComponent:PHPSESSID];
    NSHTTPCookie *sessionIDCookie = [NSKeyedUnarchiver unarchiveObjectWithFile:saveFile];
    if (!!sessionIDCookie) {
        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:sessionIDCookie];
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runtime（一）之 Message转发浅析]]></title>
    <link href="http://Handy-Wang.github.io/blog/2014/03/10/runtime-1rd-message/"/>
    <updated>2014-03-10T15:52:57+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2014/03/10/runtime-1rd-message</id>
    <content type="html"><![CDATA[<h3>Objective-C对象模型</h3>


<p>本文假定您对Objective-C对象模型已了解</p>

<p><img src="https://raw.github.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/class-diagram.jpg" width="350" height="450"></p>

<h3>消息转发两大流程</h3>


<h6>一）方法的动态决议</h6>


<h6>二）完整的消息转发机制</h6>


<!--more-->




<h3>一）方法的动态决议</h3>


<p>即程序运行时动态提供方法的实现，运行时是没有方法实现的。这一机制与消息机制不冲突，即发送消息后，如果运行时发现接收者没有消息实现，
则会触发方法<br/>
+(BOOL)resolveInstanceMethod:(SEL)sel; 和 +(BOOL)resolveClassMethod:(SEL)sel;<br/>
以拦截需要&#8221;动态决议&#8221;的方法，显而易见的是这两个方法分别对应实例方法和类方法的调用拦截。</p>

<p>针对“动态决议“的“运行时是没有方法实现”这一特性，我总结了两类动态决议的实际场景：<br/>
1）@dynamic<br/>
与@synthesis一样用于修饰属性，但@synthesis用于生成确实名称的getter、setter方法（如果@property中没有特殊指定getter、setter方法名）；@dynamic则是告诉编译器此属性的getter、setter方法的实现在运行时动态指定。<br/>
2）调用没有实现的实例方法或静态方法<br/>
因为运行时消息接收者是没有方法实现的，所以在运行时上面提到的两个方法<br />
(+(BOOL)resolveInstanceMethod:(SEL)sel; 和 +(BOOL)resolveClassMethod:(SEL)sel;)一定能被触发。</p>

<p>重点总结：<br/>
1）一定是被调用方法（静态方法和实例方法）的实现在运行时不存在，则“方法的动态决议机制”才有效，否则无效<br />
2）属性方法的动态决议体现在：@dynamic修饰属性以及配合方法 +(BOOL)resolveInstanceMethod:(SEL)sel; 来指定方法的实现<br />
3）通过runtime相关函数提供方法的动态实现时，如果方法实现有返回值，那么返回值必须是对象类型不能为基本数据类型(通过代码实验证明)<br /></p>

<p>知识扩展<br />
使用runtime相关函数在运行时添加静态和实例方法实现时，发现一些小知识点。<br />
1）实例对象、类、类对象、元类对象、相关方法</p>

<pre><code>实例对象 instance object, 通过Frameworks里的类(或自己定义的类)实例化得到的对象叫实例对象，
    如:AboutMethods *am = [[[AboutMethods alloc] init]]; am就是实例对象。实例对象的isa指向其类对象。

类 class，定义用于抽象一类事物的数据结构

类对象 class object, 在Objective-C中任何的类定义都是对象。
    即在程序启动的时候任何类定义都对应于一块内存。
    在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,
    也就是Apple说的类对象(class object), 它是一个单例(singleton)。
    官方文档中是这样说的： The class object is the compiled version of the class
    类对象(class object)中存储了关于实例对象(instace object)所属的类的定义的
    一切：包括变量，方法，遵守的协议等等

元类对象 metaclass object, 实际上，类对象是元类对象的一个实例。
    元类对象描述了一个类对象，就像类对象描述了普通对象一样。
    不同的是元类对象的方法列表是类方法的集合，由类对象的选择器来响应。
    当向一个类发送消息时，objc_msgSend会通过类对象的isa指针定位到元类对象，
    并检查元类的方法列表（包括父类）来决定调用哪个方法。元类对象代替了类对象描述了类方法，
    就像类对象代替了实例对象描述了实例方法

类对象和元类对象的相关方法
    1. object_getClass 跟随对象的isa指针，返回此对象所属的类，对于实例对象(instance object)返回
        的是类对象(class object),
        对于类对象(class object)则返回的是元类对象(metaclass object),
    2. -class方法对于实例对象(instance)会返回类对象(class object), 对于类对象(class object)有方法+class
        则不会返回元类(metaclass object), 而只会返回类对象本身,即[@"instance" class]返回的是
        __NSCFConstantString, 而[NSString class]返回的是NSString。
        注：类名出现在消息表达式([])中作为消息接收者时表示类对象class object.
    3. class_isMetaClass 可判断某类是否为元类.                                     
    4. 使用objc_allocateClassPair可在运行时创建新的类与元类对，使用class_addMethod和
        class_addIvar可向类中增加方法和实例变量,
        最后使用objc_registerClassPair注册后，就可以使用此类了。
</code></pre>

<p>2）self、[self class]、[[self class] class]、[类名 class]、[[类名 class] class]、objc_getMetaClass[&lsquo;类名&rsquo;]、self->isa、[类名 class]&ndash;>isa、self->isa->isa的区别：</p>

<pre><code>要区分它们之前，首先要考虑调用它们的上下文：实例方法里和静态方法里， 以下分析假设有一个类名为AboutMethods
    如果是静态方法里调用：
        1.self 即类对象class object
        2.[self class] self表示类对象,从上面相关知识中了解到[类对象 class]还是返回类对象
        3.[[self class] class]、[类名 class]、[[类名 class] class] 如2.分析，
            都是获取类对象class object
        4.objc_getMetaClass["类名"] 从这个runtime函数名上即可知道这是获取类的metaclass，
            即元类对象metaclass object
            如：objc_getMetaClass("AboutMethods") 返回的是AboutMethods类的元类对象metaclass object
        5. self-&gt;isa、[类名 class]-&gt;isa 如前面所述，self、[xxx class]都是返回类对象class object，
            那么类对象的isa就是元类对象metaclass object
        6. self-&gt;isa-&gt;isa 因为self-&gt;isa是metaclass object，根据OC对象模式图知self-&gt;isa-&gt;isa是
            root metaclass object, 即NSOjbect的metaclass
    如果是实例方法里调用：
        1.self 指实例对象
        2.[self class] 指类对象
        3.[[self class] class]、[类名 class]、[[类名 class] class] 同静态方法里，都是获取类对象
        4.objc_getMetaClass["类名"] 同静态方法里，即获取元类对象metaclass object
        5. self-&gt;isa 由于self是实例对象instance object，所以self-&gt;isa获取的是类对象class object
        6. [类名 class]-&gt;isa 由于[类名 class]获取的是类对象class object,
                所以[类名 class]-&gt;isa获取到的是元类对象metaclass object.
        7. self-&gt;isa-&gt;isa 由于self是实例对象，所以self-&gt;isa表示类对象
                那么self-&gt;isa-&gt;isa表示是元类对象
        8. 注：在实例对象上直接调用isa已经被抛弃了，建议用object_getClass()函数
</code></pre>

<p>疑问：<br />
1）实例对象的创建过程？<br /></p>

<pre><code>类的编译过程、对象的创建过程，编译时与运行时的关系
</code></pre>

<p>2）类对象、元类对象的创建过程？</p>

<h3>二）完整的消息转发机制</h3>


<p>在运行时向消息接受者发送消息，消息接受者在收到消息请求后会从自己的类对象、父类对象中的method_list链表中查询消息实现的地址入口IMP。
如果在这些地方都没有找到发送的消息实现的地址入口，则rumtime运行时环境会向消息接收者发送一个forwardInvocation:消息，
并且把原始的消息以及消息的参数打成一个NSInvocation的一个对象里面，作为forwardInvocation:的唯一的参数。
forwardInvocation:本身是在NSObject里面定义的，如果你需要重载这个方法的话，那么任何试图向你的类发送一个没有定义的消息的话，
你都可以在forwardInvocation:里面捕捉到，并且把消息送到某一个安全的地方，从而避免了系统报错。</p>

<p>注意：<br />
1）重载 &ndash; (void)forwardInvocation:(NSInvocation <em>)anInvocation;的同时需要重载方法 &ndash; (NSMethodSignature </em>)methodSignatureForSelector:(SEL)sel;</p>

<pre><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
    NSLog(@"///////%@", NSStringFromSelector(_cmd));
    NSMethodSignature *sig = [_sub methodSignatureForSelector:sel];
    return sig;
}

- (void)forwardInvocation:(NSInvocation *)anInvocation {
    NSLog(@"///////%@", NSStringFromSelector(_cmd));
    [anInvocation invokeWithTarget:_sub];
}
</code></pre>

<h3>参考</h3>


<p><a href="http://www.cnblogs.com/yaski/archive/2009/04/13/1434308.html">http://www.cnblogs.com/yaski/archive/2009/04/13/1434308.html</a>
<a href="http://www.cnblogs.com/liufeng24/p/3561852.html">http://www.cnblogs.com/liufeng24/p/3561852.html</a>
<a href="http://blog.csdn.net/wzzvictory/article/details/8592492">http://blog.csdn.net/wzzvictory/article/details/8592492</a>
<a href="http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/">http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App UI调试工具（三）· Reveal App]]></title>
    <link href="http://Handy-Wang.github.io/blog/2014/01/03/ios-app-uidiao-shi-gong-ju-san-reveal/"/>
    <updated>2014-01-03T20:53:01+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2014/01/03/ios-app-uidiao-shi-gong-ju-san-reveal</id>
    <content type="html"><![CDATA[<p>昨天，经<a target="_blank" href="http://weibo.com/danc">@Dan</a>推荐又了解到一款UI调试神器<code>Reveal App</code>
<video width='640' height='320' preload='none' controls poster='http://revealapp.com/img/testimonial-flipboard.jpg'><source src='http://revealapp.com/video/Reveal.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'></video></p>

<!--more-->


<p>官方地址在<a target="_blank" href="http://revealapp.com/">这里</a>
<code>注意：我今天下的试用版试用总是提示已过期，一气之下就把系统日期改成2013年01月03日了，再启动，可以试用了。</code></p>

<p>集成向导：
Reveal App安装完成后，点开菜单Help->Getting Started，会出现一个界面，界面里有三个步骤，点界面左下角的“View Integration Guide”会打开一个本地的网页，这个网页里详细的描述了
集成静态库和动态库的步骤。</p>

<p>OK，大家可以试用一下。截止目前介绍的三款中，感觉这款的UE最NB，绝对产品级的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[由kIOS6MEMORYWARNING引发的思考]]></title>
    <link href="http://Handy-Wang.github.io/blog/2013/12/26/you-kios6memorywarningyin-fa-de-si-kao/"/>
    <updated>2013-12-26T21:09:31+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2013/12/26/you-kios6memorywarningyin-fa-de-si-kao</id>
    <content type="html"><![CDATA[<p>昨晚，在Review搜狐新闻客户端代码时发现iOS6+时ViewController类里的didReceiveMemoryWarning方法实现被宏kIOS6MEMORYWARNING(它的值是0)屏蔽了。(<a target="_blank" href="http://weibo.com/chh1980?topnav=1&wvr=5&topsug=1">@陈宏-Wesley</a>)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didReceiveMemoryWarning</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">didReceiveMemoryWarning</span><span class="p">];</span>
</span><span class='line'>    <span class="err">#</span><span class="k">if</span> <span class="n">kIOS6MEMORYWARNING</span>
</span><span class='line'>    <span class="c1">// only want to do this on iOS 6</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([[[</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">systemVersion</span><span class="p">]</span> <span class="n">floatValue</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">6.0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//  Don&#39;t want to rehydrate the view if it&#39;s already unloaded</span>
</span><span class='line'>        <span class="kt">BOOL</span> <span class="n">isLoaded</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">isViewLoaded</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//  We check the window property to make sure that the view is not visible</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">isLoaded</span> <span class="o">&amp;&amp;</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">window</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">//  Give a chance to implementors to get model data from their views</span>
</span><span class='line'>            <span class="p">[</span><span class="n">self</span> <span class="nl">performSelectorOnMainThread:</span><span class="k">@selector</span><span class="p">(</span><span class="n">viewWillUnload</span><span class="p">)</span>
</span><span class='line'>                                   <span class="nl">withObject:</span><span class="nb">nil</span>
</span><span class='line'>                                <span class="nl">waitUntilDone:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">//  Detach it from its parent (in cases of view controller containment)</span>
</span><span class='line'>            <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="n">removeFromSuperview</span><span class="p">];</span>
</span><span class='line'>            <span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>    <span class="c1">//  Clear out the view.  Goodbye!</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">//  The view is now unloaded...now call viewDidUnload</span>
</span><span class='line'>            <span class="p">[</span><span class="n">self</span> <span class="nl">performSelectorOnMainThread:</span><span class="k">@selector</span><span class="p">(</span><span class="n">viewDidUnload</span><span class="p">)</span>
</span><span class='line'>                                   <span class="nl">withObject:</span><span class="nb">nil</span>
</span><span class='line'>                                <span class="nl">waitUntilDone:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>刹那间觉得很奇怪，一定有一些不为人知的原因，所以我打算一探究竟。</p>

<!--more-->


<p>经过和 <a target="_blank" href="http://weibo.com/iqipei?topnav=1&wvr=5&topsug=1">@单eye皮</a> <a target="_blank" href="http://weibo.com/u/1620329427?topnav=1&wvr=5&topsug=1">@Aaron_亚伦007</a> 一天的激烈讨论得出了一些我们认为正确的答案，特总结如下。</p>

<p>iOS6以前(不包括iOS6)，内存警告后，我们都会在viewDidUnload方法里手动的回收ViewController里的子View以及ViewController的View([self.view removeFromSuperview];self.view = nil;)，当ViewController通过loadView重建时ViewController的View和子View全部会被重建(一般在loadView和viewDidLoad里)。所以，iOS6以前(不包括iOS6)两个关键点：1）MemoryWarning时viewDidUnload一定会被调到；2）为了重建loadView被调用多次；</p>

<p>iOS6及以后内存警告时，didReceiveMemoryWarning会被调到但viewDidUnload方法已经不会被调到。按iOS6以下的思维或没看官方文档前，我们会觉得这样有不妥，所以我们会在didReceiveMemoryWarning方法里手动调用viewDidUnload方法来回收ViewController的View和子View，以使我们内心觉得真NB，完美解决了iOS6以前和
iOS6及以后内存警告的处理了。所以，文章开头的代码片断里在iOS6及以后会手动调用viewDidUnload方法，即，回收ViewController子View和ViewController的View。</p>

<p>如果觉得上面处理iOS6及以后内存警告的方式很NB的话，那么我们还可以更NB。其实，Apple已经为了考虑到iOS6以后内存警告应该怎么处理。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">On</span> <span class="n">iOS</span> <span class="mi">6</span> <span class="n">and</span> <span class="n">Later</span><span class="p">,</span> <span class="n">a</span> <span class="n">View</span> <span class="n">Controller</span> <span class="n">Unloads</span> <span class="n">Its</span> <span class="n">Own</span> <span class="n">Views</span> <span class="n">When</span> <span class="n">Desired</span>
</span><span class='line'><span class="n">The</span> <span class="k">default</span> <span class="n">behavior</span> <span class="k">for</span> <span class="n">a</span> <span class="n">view</span> <span class="n">controller</span> <span class="n">is</span> <span class="n">to</span> <span class="n">load</span> <span class="n">its</span> <span class="n">view</span> <span class="n">hierarchy</span>
</span><span class='line'><span class="n">when</span> <span class="n">the</span> <span class="n">view</span> <span class="n">property</span> <span class="n">is</span> <span class="n">first</span> <span class="n">accessed</span> <span class="n">and</span> <span class="n">thereafter</span> <span class="n">keep</span> <span class="n">it</span> <span class="k">in</span> <span class="n">memory</span> <span class="n">until</span>
</span><span class='line'><span class="n">the</span> <span class="n">view</span> <span class="n">controller</span> <span class="n">is</span> <span class="n">disposed</span> <span class="n">of</span><span class="p">.</span>
</span><span class='line'><span class="n">The</span> <span class="n">memory</span> <span class="n">used</span> <span class="n">by</span> <span class="n">a</span> <span class="n">view</span> <span class="n">to</span> <span class="n">draw</span> <span class="n">itself</span> <span class="n">onscreen</span> <span class="n">is</span> <span class="n">potentially</span> <span class="n">quite</span> <span class="n">large</span><span class="p">.</span> <span class="n">However</span><span class="p">,</span>
</span><span class='line'><span class="n">the</span> <span class="n">system</span> <span class="n">automatically</span> <span class="n">releases</span> <span class="n">these</span> <span class="n">expensive</span> <span class="n">resources</span> <span class="n">when</span> <span class="n">the</span> <span class="n">view</span> <span class="n">is</span> <span class="n">not</span> <span class="n">attached</span>
</span><span class='line'><span class="n">to</span> <span class="n">a</span> <span class="n">window</span><span class="p">.</span> <span class="n">The</span> <span class="n">remaining</span> <span class="n">memory</span> <span class="n">used</span> <span class="n">by</span> <span class="n">most</span> <span class="n">views</span> <span class="n">is</span> <span class="n">small</span> <span class="n">enough</span> <span class="n">that</span> <span class="n">it</span> <span class="n">is</span> <span class="n">not</span> <span class="n">worth</span>
</span><span class='line'><span class="n">it</span> <span class="k">for</span> <span class="n">the</span> <span class="n">system</span> <span class="n">to</span> <span class="n">automatically</span> <span class="n">purge</span> <span class="n">and</span> <span class="n">recreate</span> <span class="n">the</span> <span class="n">view</span> <span class="n">hierarchy</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="n">You</span> <span class="n">can</span> <span class="n">explicitly</span> <span class="n">release</span> <span class="n">the</span> <span class="n">view</span> <span class="n">hierarchy</span> <span class="k">if</span> <span class="n">that</span> <span class="n">additional</span> <span class="n">memory</span> <span class="n">is</span>
</span><span class='line'><span class="n">necessary</span> <span class="k">for</span> <span class="n">your</span> <span class="n">app</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面，就这一段话展开分析和解释：
iOS6及以后，内存警告时系统会回收ViewController的View的CALayer里的BitMap（CABackingStore类型，它的内容是直接用于渲染到屏幕，它是View消耗内存的大户）。view和calayer占的内存极少，
数量级也就在byte和kbyte之间，所以系统只回收了BitMap，但是这里所谓的回收只是给BitMap占用的内存打了一个volatile标记表明这部分内存是可能随时被其它数据占用,平时没内存警告时正在使用的内存标记为In use，完全被释放回收的标记为Not in use。概括起来也就是说：iOS6及以后的内存警告时，系统会给用于渲染视图的数据(BitMap)内存打一个volatile，
ViewController的View的架子结构并不会回收，当View再次被访问时，虽然View的架子结构会用重建，但触发drawRect来渲染界面时，如果view对应的BitMap数据内存没有被占用则会被View的drawRect方法直接渲染出来且内存被标记为in use，从而这块内存又可以独享了；如果已被其它数据占用，那么BitMap必须要重建。所以可以看到整个重建过程不再是由loadView来做的，它是通过对view的访问来触发的。但是，请注意，
如果说在iOS6及以后ViewController的loadView方法只会被调用一次，这种说法是不完全准确的。因为：如果在didReceiveMemoryWarning里把ViewController的View也回收了([self.view removeFromSuperview];self.view = nil;)，那么当再次有对View访问时，loadView会被调用以进行完全最彻底的重建(想想也是，ViewController的View都没了，不调loadView来重建那怎么办呢)。</p>

<p>总结一下：
iOS6的这种设计高明在两个地方：1）视图结构和视图数据的分离；2）内存警告后系统只回收的是内存大户视图数据，但是回收不是完全的清掉，而只是做个标记，这样既做到减小了每次重建BitMap
的成本，同时也把这部分内存开放出去可以随时被别的数据占用；3）重建时，充其量是重建BitMap(没被占用时是直接用不用重建)</p>

<p>回顾kIOS6MEMORYWARNING这个宏，如果kIOS6MEMORYWARNING==0，那么不回收View的架子结构，loadView也就不会被再次调用(没有必要嘛)；如果kIOS6MEMORYWARNING==1，那么回收View的架子结构，
再次访问View时loadView会被调用，loadView里的逻辑又运行了一次，这样不但降低了渲染速度还提高了重建成本。</p>

<p>所以，我只能这么说，iOS6及以后didReceiveMemoryWarning方法里面没有必要做任何事情，要做最多也是回收视图的架子结构或回收一些业务上处理的大数据。（你觉得真的有必要回收视图架子结构吗，这就是为什么文章一开始提到kIOS6MEMORYWARNING屏蔽了didReceiveMemoryWarning方法的实现，因为没有必要回收架子结构）</p>

<p>特别感谢：<a target="_blank" href="http://weibo.com/iqipei?topnav=1&wvr=5&topsug=1">@单eye皮</a> <a target="_blank" href="http://weibo.com/u/1620329427?topnav=1&wvr=5&topsug=1">@Aaron_亚伦007</a></p>

<h3>参考</h3>


<ol style="margin-top:-18px; padding-left:28px;">
    <li style="padding-bottom:10px;">
        <a target="_blank" href="http://blog.devtang.com/blog/2013/05/18/goodbye-viewdidunload/">《再见，viewDidUnload方法</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a target="_blank" href="http://weibo.com/tangqiaoboy?topnav=1&wvr=5&topsug=1">by @唐巧_boy</a><br/>
    </li>
    <li>
        <a target="_blank" href=" https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ViewLoadingandUnloading/ViewLoadingandUnloading.html">《Resource Management in View Controllers》</a><br/>
    </li>
    <li>
        <a target="_blank" href="http://blog.spacemanlabs.com/2011/08/calayer-internals-contents/">《CALayer Internals: Contents》</a><br/>
    </li>
    <li>
        <a target="_blank" href="http://blog.csdn.net/mad2man/article/details/11177293">《viewDidUnload 和 viewWillUnload 被废弃之后的内存警告处理》</a><br/>
    </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OS下搭建APNS推送服务器(Apache+PHP)]]></title>
    <link href="http://Handy-Wang.github.io/blog/2013/12/19/mac-osxia-da-jian-apnstui-song-fu-wu-qi/"/>
    <updated>2013-12-19T21:16:04+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2013/12/19/mac-osxia-da-jian-apnstui-song-fu-wu-qi</id>
    <content type="html"><![CDATA[<h3>配置Apache+PHP</h3>


<p>Mac OS自带Apache服务器和PHP，所以只需少许配置便可将它派上用场</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1）启动Apache服务器
</span><span class='line'>打开“终端（terminal）”，然后（注意，sudo需要的密码就是系统的root帐号密码）运行“sudo apachectl start”
</span><span class='line'>再输入帐号密码这样Apache就运行了。如此在浏览器中输入“http://localhost”就可以看到一个内容为“It works!”
</span><span class='line'>的页面。其位于“/Library/WebServer/Documents/”下，这就是Apache的默认根目录
</span><span class='line'>
</span><span class='line'>2）配置Apache支持PHP
</span><span class='line'>在终端中运行“sudo vi /etc/apache2/httpd.conf”，打开Apache的配置文件。
</span><span class='line'>找到“#LoadModule php5_module libexec/apache2/libphp5.so”，把前面的#号去掉，
</span><span class='line'>保存（在命令行输入:w）并退出vi（在命令行输入:q）。运行“sudo apachectl restart”，
</span><span class='line'>重启Apache，这样PHP就可以用了。
</span><span class='line'>
</span><span class='line'>3）测试PHP在Apache中运行是否正常
</span><span class='line'>运行“sudo cp /Library/WebServer/Documents/index.html.en /Library/WebServer/Documents/info.php”
</span><span class='line'>即在Apache的根目录下复制index.html.en文件并重命名为info.php。
</span><span class='line'>在终端中运行“sudo vi /Library/WebServer/Document/info.php”，这样就可以在vi中编辑info.php文件了。
</span><span class='line'>在“It’s works!”后面加上“&lt;?php phpinfo(); ?&gt;”，然后保存之。如此就可以在http://localhost/info.php中看到
</span><span class='line'>有关PHP的信息，比如10.8中内置PHP版本号是5.3.13。</span></code></pre></td></tr></table></div></figure>


<!--more-->


<h3>制作Pem文件</h3>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1）打开keychain，选择左上Keychains区域中的login，再选择左下Category区域中的My Certificates，
</span><span class='line'>然后在右边找到项目使用的Push证书(注意：当有developement和production时一定要记住你导出的是哪个)
</span><span class='line'>后面做测试时无论是打包还是直接build在device的App都要使用对应的codesign.
</span><span class='line'>
</span><span class='line'>2）分别把Certificate和key的p12导出，命名为cert.p12和key.p12
</span><span class='line'>
</span><span class='line'>3）打开terminal运行以下代码：
</span><span class='line'>    openssl pkcs12 -clcerts -nokeys -out cert.pem -in cert.p12
</span><span class='line'>    openssl pkcs12 -nocerts -out key.pem -in key.p12
</span><span class='line'>    openssl rsa -in key.pem -out key-noenc.pem
</span><span class='line'>    cat cert.pem key-noenc.pem &gt; apns.pem
</span><span class='line'>把最后生成的apns.pem保管好</span></code></pre></td></tr></table></div></figure>




<h3>编写PHP页面</h3>


<p>在Apache根录下新建一个index.php文件，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;html&gt;
</span><span class='line'>&lt;head&gt;
</span><span class='line'>  &lt;title&gt;Push Simulator&lt;/title&gt;
</span><span class='line'>  &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
</span><span class='line'>  &lt;meta id="viewport" name="viewport"content="width=320; initial-scale=1.0;maximum-scale=1.0;user-scalable=no;"/&gt;
</span><span class='line'>  &lt;script language="javascript"&gt;
</span><span class='line'>      function onTokenChange(value) {
</span><span class='line'>          if (value == "other") {
</span><span class='line'>              var token_other = document.getElementById("token_other");
</span><span class='line'>              token_other.style.display = "inline"
</span><span class='line'>          }
</span><span class='line'>          else {
</span><span class='line'>              var token_other = document.getElementById("token_other");
</span><span class='line'>              token_other.style.display = "none"
</span><span class='line'>          }
</span><span class='line'>      };
</span><span class='line'>  &lt;/script&gt;
</span><span class='line'>&lt;/head&gt;
</span><span class='line'>&lt;body&gt;
</span><span class='line'>  &lt;h2 style="border-bottom:red solid 1px;"&gt;Push Simulator&lt;/h2&gt;
</span><span class='line'>  &lt;form action="a.php" method="post"&gt;
</span><span class='line'>      &lt;div&gt;Badge number&lt;/div&gt;
</span><span class='line'>      &lt;div&gt;
</span><span class='line'>          &lt;input style="width:40px;" value="1" name="badgeNumber"&gt;&lt;/input&gt;
</span><span class='line'>      &lt;/div&gt;
</span><span class='line'>      &lt;br /&gt;
</span><span class='line'>
</span><span class='line'>      &lt;div&gt;Alert message&lt;/div&gt;
</span><span class='line'>      &lt;div&gt;
</span><span class='line'>          &lt;input style="width:150px;" value="新消息内容" name="msg"&gt;&lt;/input&gt;
</span><span class='line'>      &lt;/div&gt;
</span><span class='line'>      &lt;br /&gt;
</span><span class='line'>
</span><span class='line'>      &lt;div&gt;Link2&lt;/div&gt;
</span><span class='line'>      &lt;div&gt;
</span><span class='line'>          &lt;input style="width:450px;" value="video://vid=1605673&mid=10348504&columnId=117&channelId=1" name="link2"&gt;&lt;/input&gt;
</span><span class='line'>      &lt;/div&gt;
</span><span class='line'>      &lt;br /&gt;
</span><span class='line'>
</span><span class='line'>      &lt;div&gt;
</span><span class='line'>          Token:
</span><span class='line'>          &lt;select name="token" id="tokenSelect" onchange="onTokenChange(this.options[this.options.selectedIndex].value);"&gt;
</span><span class='line'>              &lt;option value="4e52bb2a215643c0da52477177ba19793720ebc17ec5a38aa853a68a22ab7f93"&gt;token1&lt;/option&gt;
</span><span class='line'>              &lt;option value="other"&gt;Other&lt;/option&gt;
</span><span class='line'>          &lt;/select&gt;
</span><span class='line'>          &lt;input style="width:450px;display:none;" value="" id="token_other" name="token_other"&gt;
</span><span class='line'>      &lt;/div&gt;
</span><span class='line'>      &lt;div&gt;
</span><span class='line'>          Schema:
</span><span class='line'>          &lt;select name="schema"&gt;
</span><span class='line'>              &lt;option value="apns.pem"&gt;apns.pem&lt;/option&gt;
</span><span class='line'>          &lt;/select&gt;
</span><span class='line'>      &lt;/div&gt;
</span><span class='line'>      &lt;br /&gt;
</span><span class='line'>
</span><span class='line'>      &lt;div&gt;
</span><span class='line'>          &lt;input type="submit" value="发送"&gt;&lt;/input&gt;
</span><span class='line'>      &lt;/div&gt;
</span><span class='line'>  &lt;/form&gt;
</span><span class='line'>&lt;/body&gt;
</span><span class='line'>&lt;/html&gt;</span></code></pre></td></tr></table></div></figure>


<p>再在Apache根录下新建一个a.php文件(这个文件才是真正用来发推送的)，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?php
</span><span class='line'>/*
</span><span class='line'>* 文件名称：Lib_Push_IPhone_Server.php
</span><span class='line'>* 摘    要：苹果PUSH发送类
</span><span class='line'>* 版    本：1.0
</span><span class='line'>*/
</span><span class='line'>class Lib_Push_IPhone_Server  {
</span><span class='line'>  //发布版的server：gateway.push.apple.com 开发版：gateway.sandbox.push.apple.com
</span><span class='line'>  private $apnsHost = 'gateway.sandbox.push.apple.com';
</span><span class='line'>  private $apnsPort = '2195';
</span><span class='line'>  private $sslPem = ''; //开发版本和发布版的pem不一样，用不同的证书生成
</span><span class='line'>  private $passPhrase = 'sohu';
</span><span class='line'>  private $apnsConnection = null ;
</span><span class='line'> 
</span><span class='line'>  public function __destruct(){
</span><span class='line'>  //退出时，关闭到苹果服务器的连接
</span><span class='line'>      $this-&gt;closeConnections();
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>  //建立到苹果服务器的连接
</span><span class='line'>  function connectToAPNS($pem) {
</span><span class='line'>      $streamContext = stream_context_create();
</span><span class='line'>      stream_context_set_option($streamContext, 'ssl', 'local_cert', $pem);
</span><span class='line'>      $this-&gt;apnsConnection = stream_socket_client('ssl://'.$this-&gt;apnsHost.':'.$this-&gt;apnsPort, $error, $errorString, 60, STREAM_CLIENT_CONNECT, $streamContext);
</span><span class='line'>      if($this-&gt;apnsConnection == false) {
</span><span class='line'>          $this-&gt;Nslog("Failed to connect {".$error."} {".$errorString."}");
</span><span class='line'>          $this-&gt;closeConnections();
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  //发送消息到苹果
</span><span class='line'>  function sendNotification($deviceToken, $message) {
</span><span class='line'>      if(!$this-&gt;apnsConnection){
</span><span class='line'>          $this-&gt;connectToAPNS();
</span><span class='line'>      }
</span><span class='line'>      $apnsMessage = chr(0) . chr(0) . chr(32) . pack('H*', str_replace(' ', '', $deviceToken)) . chr(0) . chr(strlen($message)) . $message;
</span><span class='line'>      return fwrite($this-&gt;apnsConnection, $apnsMessage);
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  //关闭到苹果服务器的连接
</span><span class='line'>  function closeConnections() {
</span><span class='line'>      fclose($this-&gt;apnsConnection);
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  function NsLog($logmsg) {
</span><span class='line'>      print date("Y-m-d H:i:s")."\t".$logmsg."\n";
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>?&gt;
</span><span class='line'>
</span><span class='line'>&lt;?php
</span><span class='line'>    //=========================
</span><span class='line'>    $schema           = $_POST['schema'];
</span><span class='line'>    $badgeNumber  = $_POST['badgeNumber'];
</span><span class='line'>    $msg          = $_POST['msg'];
</span><span class='line'>    $link2            = $_POST['link2'];
</span><span class='line'>    $token            = $_POST['token'];
</span><span class='line'>    $token_other  = $_POST['token_other'];
</span><span class='line'>    if ($token == 'other') {
</span><span class='line'>        $token = $token_other;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    $body = array();
</span><span class='line'>    $body['aps'] = array('alert' =&gt; $msg);
</span><span class='line'>    $body['aps']['badge'] = $badgeNumber;
</span><span class='line'>    $body['url'] = $link2;
</span><span class='line'>    $payload = json_encode($body);
</span><span class='line'>    $push = new Lib_Push_IPhone_Server();
</span><span class='line'>
</span><span class='line'>    $push-&gt;connectToAPNS($schema);
</span><span class='line'>    $push-&gt;sendNotification($token, $payload);
</span><span class='line'>    $push-&gt;closeConnections();
</span><span class='line'>?&gt;
</span><span class='line'>
</span><span class='line'>&lt;title&gt;iOS PushNotification Simulator&lt;/title&gt;
</span><span class='line'>&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
</span><span class='line'>&lt;meta id="viewport" name="viewport"content="width=320; initial-scale=1.0;maximum-scale=1.0;user-scalable=no;"/&gt;
</span><span class='line'>&lt;body&gt;
</span><span class='line'>    &lt;div&gt;&lt;a href="javascript:history.back();"&gt;&lt;&lt;&lt;&lt;返回&lt;/a&gt;&lt;/div&gt;
</span><span class='line'>    &lt;div&gt;Schema&lt;/div&gt;
</span><span class='line'>    &lt;div&gt;&lt;?=$schema?&gt;&lt;/div&gt;
</span><span class='line'>    &lt;br /&gt;
</span><span class='line'>    
</span><span class='line'>    &lt;div&gt;Badge Number&lt;/div&gt;
</span><span class='line'>    &lt;div&gt;&lt;?=$badgeNumber?&gt;&lt;/div&gt;
</span><span class='line'>    &lt;br /&gt;
</span><span class='line'>    
</span><span class='line'>    &lt;div&gt;Alert Message&lt;/div&gt;
</span><span class='line'>    &lt;div&gt;&lt;?=$msg?&gt;&lt;/div&gt;
</span><span class='line'>    &lt;br /&gt;
</span><span class='line'>
</span><span class='line'>    &lt;div&gt;Link2&lt;/div&gt;
</span><span class='line'>    &lt;div&gt;&lt;?=$link2?&gt;&lt;/div&gt;
</span><span class='line'>    &lt;br /&gt;
</span><span class='line'>    
</span><span class='line'>    &lt;div&gt;Token&lt;/div&gt;
</span><span class='line'>    &lt;div&gt;&lt;?=$token?&gt;&lt;/div&gt;
</span><span class='line'>    &lt;br /&gt;
</span><span class='line'>&lt;/body&gt;</span></code></pre></td></tr></table></div></figure>


<p>再把apns.pem拷到Apache根目录下，然后重启Apche: sudo apachectl restart</p>

<h3>配置index.php为默认首页</h3>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>找到
</span><span class='line'>&lt;IfModule dir_module&gt;
</span><span class='line'>    DirectoryIndex index.html
</span><span class='line'>&lt;/IfModule&gt;
</span><span class='line'>修改为
</span><span class='line'>&lt;IfModule dir_module&gt;
</span><span class='line'>    DirectoryIndex index.php index.html
</span><span class='line'>&lt;/IfModule&gt;</span></code></pre></td></tr></table></div></figure>


<p>重启Apche: sudo apachectl restart</p>

<h3>测试</h3>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>在浏览器地址栏里输入http://apache服务器地址，如:http://localhost，便能看到index.php页面。
</span><span class='line'>在这个页面填写相关参数便可以发送。</span></code></pre></td></tr></table></div></figure>




<h3>注意要点</h3>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1）导出cert.p12和key.p12时的p12一定要是最后测试的App对应用的codesign
</span><span class='line'>即：developent的p12对应Debug模式的App，production的p12对应AppStore模式的App
</span><span class='line'>
</span><span class='line'>2）生成pem时一定要小心
</span><span class='line'>
</span><span class='line'>3）在index.php页面测试时，一定要选择对的schema（即pem，目前只有一种，
</span><span class='line'>我的项目中有多种：debug和debug-inhouse）填对token，
</span><span class='line'>这个token要以xcode输出的为准，因为它会变化</span></code></pre></td></tr></table></div></figure>




<h3>GOOD LUCK!!!</h3>




<h3>参考</h3>


<ol style="margin-top:-18px; padding-left:28px;">
    <li style="padding-bottom:10px;">
        <a target="_blank" href="http://dancewithnet.com/2010/05/09/run-apache-php-mysql-in-mac-os-x/">在Mac OS X中配置Apache＋PHP＋MySQL</a><br/>
    </li>
    <li>
        <a target="_blank" href="http://stackoverflow.com/questions/11536587/creating-pem-file-for-push-notification">Creating.pem file for push notification</a><br/>
    </li>
</ol>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App UI调试工具（二）· Realtime Debug Portal]]></title>
    <link href="http://Handy-Wang.github.io/blog/2013/12/17/ios-app-uidiao-shi-gong-ju2/"/>
    <updated>2013-12-17T05:30:58+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2013/12/17/ios-app-uidiao-shi-gong-ju2</id>
    <content type="html"><![CDATA[<p><img src="https://github-camo.global.ssl.fastly.net/03548ab74978beee15b711ab26b5ed1bd71714f2/687474703a2f2f7777772e76696e716f6e2e636f6d2f636f6465626c6f672f66636b656469746f722f75706c6f61642f696d6167652f323031332d30362f325f322e706e67"></p>

<h3>Realtime Debug Portal简介</h3>


<blockquote><p>RDP是一个类似Web Inspector的工具，把这个工具引入我们的项目工程，并做一些简单的配置，然后启动应用，<br/>在浏览器输入手机的IP地址，就可以看到UIView的树状结构和Log信息，还可以在浏览器中对View进行移动，<br/>隐藏，选中高亮等操作。</p><footer><strong>Realtime Debug Portal</strong> <cite><a href='https://github.com/vinqon/Realtime-Debug-Portal'>Read On</a></cite></footer></blockquote>


<!--more-->




<h3>配置步骤</h3>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>把库文件、头文件以及资源文件(bundle)引入项目即可，有两点需要注意一下：
</span><span class='line'>
</span><span class='line'>把工程中的Build Settings中的Other Linker Flags设置为-ObjC;
</span><span class='line'>使用iOS5或以上SDK;
</span><span class='line'>然后在合适位置调用以下代码：
</span><span class='line'>#import "libRDP.h"
</span><span class='line'>[RDP startServer];
</span><span class='line'>启动应用之后，状态栏会显示出你需要访问的地址，模拟器一般会显示http://127.0.0.1:8080 ，
</span><span class='line'>请使用Chrome或者Safari打开。
</span><span class='line'>
</span><span class='line'>当选中某个view之后，RDP会在这个view上面盖一层蓝色透明遮罩以便开发者区别。
</span><span class='line'>用户可以通过按下方向键来移动view，每次会移动1个逻辑像素；按住shift加方向键可以移动10个逻辑像素；
</span><span class='line'>按住w字母键，加方向键可以调整大小；
</span><span class='line'>点击h可以切换hidden状态；</span></code></pre></td></tr></table></div></figure>


<p>也可参考github上<a target="_blank" href="https://github.com/vinqon/Realtime-Debug-Portal">这里</a></p>

<h3>试用体会</h3>


<div>
    1）目前，支持视图的Inspect、position和size调整、隐藏或显示
</div>


<div>
    2）方便集成到项目，UE简单明了很容易上手，基本能满足界面布局调试需求
</div>




<h3>参考</h3>


<ol style="margin-top:-18px; padding-left:28px;">
    <li style="padding-bottom:10px;">
        <a target="_blank" href="http://www.vinqon.com/codeblog/?detail/11109">Redesign Your App for iOS 7 之 页面布局</a><br/>
    </li>
    <li>
        <a target="_blank" href="https://github.com/vinqon/Realtime-Debug-Portal">Realtime Debug Portal的github</a><br/>
    </li>
</ol>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App UI调试工具（一）· Symbiote in Frank]]></title>
    <link href="http://Handy-Wang.github.io/blog/2013/12/14/ios-app-uidiao-shi-gong-ju/"/>
    <updated>2013-12-14T21:48:49+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2013/12/14/ios-app-uidiao-shi-gong-ju</id>
    <content type="html"><![CDATA[<p><img src="http://blog.thepete.net/images/post_images/2012-06-24_A.png"></p>

<h3>Frank简介</h3>


<blockquote><p>Frank is &#8216;Selenium for native iOS apps&#8217;. It allows you to write automated acceptance tests <br/>which verify the functionality of your native iOS app.</p><p>Frank是一个iOS平台的自动化测试工具。它支持编写一些自动化验收测试用例来验收iOS App的功能。</p><footer><strong>Frank</strong> <cite><a href='http://www.testingwithfrank.com/'>Read On</a></cite></footer></blockquote>


<!--more-->


<h3>Symbiote简介</h3>


<blockquote><p>Frank comes with a useful little tool called Symbiote. It’s a little web app <br/>which is embedded inside your native iOS application. Its purpose is to <br/>let you inspect the current state of your app’s UI, and to test the <br/>UIQuery selectors which Frank uses to help it automate your app. <br/>Essentially Symbiote is Firebug for your native iOS app.</p><p>Frank中包含了一个非常有用的小工具，它叫叫Symbiote。它是一个嵌入到iOS App中的一个Web应用程序。<br/>它的功能是可以让开发者能够调试运行时的iOS App UI的当前状态(层次结构、大小、位置等信息)，<br/>同时它也是为了测试Frank内部的一个用于自动化App的功能UIQuery选择器(UIQuery selector可以理解<br/>为通过某些名称或ID值找到App的UI元素，和JQuery一个设计思路)。<br/>从其功能本质上讲，Symbiote就是一个用于iOS App的FireBug。</p><footer><strong>Symbiote</strong> <cite><a href='http://blog.thepete.net/blog/2011/05/01/inspect-state-of-our-running-ios-apps/'>Read On</a></cite></footer></blockquote>




<h3>Frank以及Symbiote的环境搭建</h3>


<p>完全按照<a href="http://blog.thepete.net/blog/2012/06/24/writing-your-first-frank-test/">Writing Your First Frank Test</a>操作即可。
请注意：这个HowTo中会有Ruby环境和插件的安装，做好心理准备。
Touble shoot：<a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x6e;&#x6e;&#110;&#x77;&#106;&#x73;&#x40;&#49;&#x32;&#x36;&#46;&#x63;&#x6f;&#109;">&#x6e;&#110;&#x6e;&#119;&#x6a;&#x73;&#64;&#x31;&#x32;&#54;&#x2e;&#99;&#x6f;&#109;</a></p>

<h3>试用体会</h3>


<div>
    1）通过Web GUI界面动态展示程序运行时可视UI的层次结构和相关属性(宽、高等)
</div>


<div>
    2）操作App时，Web GUI界面和相关信息是同步变化的
</div>


<div>
    3）在Web GUI界面中点UI层次结构里某节点时，右侧的Web Simulator中会高亮出点击区域
</div>


<div>
    4）在Web GUI界面里可以通过选择节点或编写UIQuery selector来控制App
</div>


<div>
    5）Web GUI界面的UI/UE实再是太差劲了
</div>


<div>
    6）更多功能有待进一步试用&#8230;
</div>




<h3>参考</h3>


<ol style="margin-top:-18px; padding-left:28px;">
<li style="padding-bottom:10px;">
    <a target="_blank" href="http://www.cocoachina.com/applenews/devnews/2013/1111/7332.html">你用哪种工具进行iOS app自动化功能测试？</a><br/>
</li>
<li>
    <a target="_blank" href="http://moredip.github.io/frank_at_selenium_slides.html">Frank presentation slides</a><br/>
</li>
<li>
    <a target="_blank" href="http://www.testingwithfrank.com/">Testing With Frank(Frank网站)</a><br/>
</li>
<li style="padding-bottom:10px;">
    <a target="_blank" href="https://github.com/TestingWithFrank/Frank">Frank github</a><br/>
</li>
<li>
    <a target="_blank" href="http://blog.thepete.net/blog/2011/05/01/inspect-state-of-our-running-ios-apps/">Inspect the State of Your Running iOS App&#8217;s UI With Symbiote(Symbiote介绍)</a><br/>
</li>
<li>
    <a target="_blank" href="https://github.com/TestingWithFrank/symbiote">Symbiote github(介绍、Mockup static Symbiote web app)</a><br/>
</li>
<li>
    <a target="_blank" href="http://blog.thepete.net/blog/2012/06/24/writing-your-first-frank-test/">Writing Your First Frank Test(搭建Frank和Symbiote)</a>
</li>
</ol>




<h5>iOS App UI调试工具（二）里介绍另一神器：RDP</h5>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Cocos2d]]></title>
    <link href="http://Handy-Wang.github.io/blog/2013/12/09/chu-shi-cocos2d/"/>
    <updated>2013-12-09T21:26:00+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2013/12/09/chu-shi-cocos2d</id>
    <content type="html"><![CDATA[<p>俗话说『山不转水转，水不转人转，人不转需求转，需求不转代码转』，好扯，总之，各种机缘巧合已经让我无法逃离地要去了解一下这个该死的让人望而生畏的Cocos家族。</p>

<!--more-->


<p>记忆中从去年开始Cocos2d这个字眼时不时的出现在互联网上、同事谈论中，打那时起我也就只知道他是跟游戏开发相关，毕竟开发<code>搜狐新闻客户端</code>用不到它，而且在我这种长期做应用型开发的
苦逼攻城师的认识里开发游戏是一件既高级又复杂的事情，渐渐对它产生了距离感和畏惧心理。</p>

<p>往往越是担心发生的事情，其实它早已在某个阴暗的角落里萌芽、长大。终于，我要直面它了。</p>

<p>Cocos2d是Ricardo Quesada团队在2008年2月基于Python开发的开源2D游戏框架。</p>

<blockquote><p>Cocos2d is a framework for building 2D games, demos, <br/>and other graphical/interactive applications. <br/>It is built over pyglet. It provides some conventions <br/>and classes to help you structure a &#8220;scene based application&#8221;</p><footer><strong>Cocos2D</strong> <cite><a href='http://cocos2d.org/index.html'>Read On</a></cite></footer></blockquote>


<p>同年6月该团队OC版的<code>Cocos2d-iPhone</code>也面世。好敏捷呀，NB吧？有两点我没有想到，第一）Python语言，第二）开发速度</p>

<p>就在大家还在感叹<code>Cocos2d-iPhone</code>多么NB多么方便时，一个中国人，请注意他叫<code>王哲</code>干了一件让所有用Cocos2D开发游戏的小伙伴们都惊呆的事儿。2010年，这哥们儿找到了兴趣、
擅长，和商业的结合点－基于Cocos2d-iPhone架构C++语言的跨平台的Cocos2d-x<code>http://www.cocos2d-x.org/</code>版问世</p>

<blockquote><p>你是怎么开始开发Cocos2d-x的？</p><p>后来我和一个夏新同事，也就是现在带cocos2d-html5项目的林顺，一起去厦大读商学院，边读边思考管理、技术上的问题。在2010年，我们去了国内一家做操作系统的公司，我负责的那个部门是多媒体游戏。为什么去做游戏？因为整个公司里就我自己最喜欢玩游戏，而别人又不喜欢，所以我就开始入手了。当时我就想有没有一种简单的方式让别人把游戏移植过来，于是我想做一个引擎，能够方便地把iOS游戏移植到我们操作系统上面，顺便再出一个安卓版本。</p><footer><strong>王哲：爱偷懒+爱游戏=开源Cocos2d-x的生命基因</strong> <cite><a href='http://www.ituring.com.cn/article/42393'>Read On</a></cite></footer></blockquote>


<p>不得不承认这哥们儿是个实干家！之后，依托于陈昊芝以及他的<code>CocoaChina</code>下的Cocos2d-x的社区和<code>触控科技</code>，Cocos2d-x得到了青春期最好的发育，到目前Cocos2d-x已广泛应用到
游戏开发中，已经到了那种如果你不用Cocos2d-x甲方就感觉乙方不专业的程度。当前，围绕Cocos2d-x的技术产品也逐渐诞生：Cocos2d-js、Cocos2d-html5、CocosStudio、Plugin-x等。</p>

<p>最后上一张图吧，辅助对Cocos2d家族的理解。
<img src="https://raw.github.com/Handy-Wang/Handy-Wang.github.io/source/source/_posts/cocos2d-x_hierarchi.png"></p>

<p>有一天，也许我也会搞搞Cocos2d-x游戏开发。。。呵呵</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重生]]></title>
    <link href="http://Handy-Wang.github.io/blog/2013/12/08/zhong-sheng/"/>
    <updated>2013-12-08T21:35:09+08:00</updated>
    <id>http://Handy-Wang.github.io/blog/2013/12/08/zhong-sheng</id>
    <content type="html"><![CDATA[<p>『重生』－佛经天龙八部中提到的迦楼罗，500年涅磐一次，凤凰涅槃。笔者也是想了许久决定引用此名作为第一篇文章的名字。</p>

<p>其实，对于笔者来说，这里有几个意思，细细道来。</p>

<!--more-->


<p>这其一，便是许久没有写博文了，大致也有一年吧。</p>

<p>这其二，那是，额。。。其实，有一个事儿我已经纠结了几年。刚才工作那会儿，对技术的渴望是发自内心的狂野的，所以只要是浏览到自以为好的技术就要收藏到浏览器里，但是重装系统时总会
忘备份，又或是那个网页在要用的时候打不开了；后来，我开始在JavaEye上写博文了，关键技术、心得、笔记等都一股脑儿的往上放，也分了些类别，但是我觉得麻烦，还觉得乱，
界面不Too Simple Too Easy；再后来，我觉得把重要东西放在网上不靠谱，遇到要记录或笔记的都虚拟打印成PDF文件存在电脑里；再再后来，貌似EverNote开始流行了，我也开始臭屁了，
各种Note stack、Note分类搞了一片一片的，那个看上去NB呀，但是每次都要登录再往里写，现在时间一长我找个文章好一个费劲；再再再后来。。。，好了不说了。这么多种方式我必须在这里
把它们统一起来。</p>

<p>这其三，额，理由好难想。。。，嗯，对了，昨天『蛋蛋』借了我一本《淘宝技术这十年》，看了三分之一了，各种NB技术术语，各种NB的Cache，各种NB的FS(FileSystem)，这，更坚定了我写博文
的决心，平时必须要有技术积累，各种架构重构。</p>

<p>这其四，真的，Octopress的UI风格纯净，我喜欢！目标很单纯，就是为了写博客而写博客，而且目前我所它架在github里了。</p>

<p>这些理由充分吗，呵呵，其实就是想自己的博文在这里改头换面并一直坚持下去，让每一篇文章都充满故事。</p>

<p>这篇也有故事。写到这里，Octopress让我有一种似曾相识的感觉，是的，多年前我就在github上用Liquid写过主页，向我推荐的这个人是一位故友－Zigzag</p>

<p>已逝的行为、精神、灵魂，涅槃重生吧。</p>
]]></content>
  </entry>
  
</feed>
